<html><head><meta http-equiv="Content-Type" content="text/html; charset=KOI8-R"><title>
        Учебник по FreeBSD, OpenBSD, NetBSD, DragonFly: C.2. Конфигурационный файл pf.conf(5)</title><link rel="stylesheet" href="pf_02_files/default.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><meta name="keywords" content="BSD, OpenBSD, FreeBSD, NetBSD, DragonFly"><link rel="start" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/index.html" title="BSDA в вопросах и ответах"><link rel="up" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apc.html" title="Приложение C. Пакетный фильтр OpenBSD&nbsp;&#8212; pf(4)"><link rel="prev" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs01.html" title="C.1. Введение в работу с пакетным фильтром OpenBSD"><link rel="next" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs03.html" title="C.3. Управление пакетным фильтром OpenBSD
      при помощи утилиты pfctl(8)"></head><body link="#0000ff" text="black" vlink="#840084" alink="#0000ff" bgcolor="white"><div class="navheader"><table summary="Navigation header" width="100%"><tbody><tr><th></th><th align="center">C.2. Конфигурационный файл <code class="filename">pf.conf(5)</code></th><th align="right"><script type="text/javascript" src="pf_02_files/orphus.js"></script><a title="Система Orphus" href="http://orphus.ru/" id="orphus" target="_blank"><img alt="Система Orphus" src="pf_02_files/orphus.gif" border="0"></a></th></tr><tr><td width="20%" align="left"><a accesskey="p" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs01.html"><img src="pf_02_files/prev.gif" alt="Пред."></a>&nbsp;</td><th width="60%" align="center">Приложение C. Пакетный фильтр <span class="acronym">OpenBSD</span>&nbsp;&#8212; <span><strong class="command">pf(4)</strong></span></th><td width="20%" align="right">&nbsp;<a accesskey="n" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs03.html"><img src="pf_02_files/next.gif" alt="След."></a></td></tr></tbody></table><hr></div><div class="section" lang="ru"><div class="titlepage"><div><div><h2 class="title" style="clear: both;"><a name="pf-pf.conf"></a>C.2. Конфигурационный файл <code class="filename">pf.conf(5)</code></h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-base"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1. Основы конфигурирования пакетного фильтра</a></span></dt><dd><dl><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-lists"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.1. Списки</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-macro"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.2. Макросы</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-tables"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.3. Таблицы</a></span></dt><dd><dl><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-tables+pfctl"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.3.1. Манипулирование таблицами с помощью утилиты
          <span><strong class="command">pfctl(8)</strong></span></a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-address"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.3.2. Адреса</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-address-area"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.3.3. Соответствие адресам</a></span></dt></dl></dd><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-filter"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.4. Фильтрация пакетов</a></span></dt><dd><dl><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rule-syntax"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.4.1. Синтаксис правил</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rule-politic"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.4.2. Политика</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rule-pass"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.4.3. Пропускаем трафик</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rule-quick"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.4.4. Ключевое слово <code class="code">quick</code></a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rule-state"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.4.5. Отслеживание состояния соединения</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rule-udp-state"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.4.6. Хранение состояний для UDP</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rule-state-opts"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.4.7. Опции таблицы состояний</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rule-flags"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.4.8. TCP флаги</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rule-synproxy"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.4.9. TCP SYN proxy</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rule-spoofing"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.4.10. Борьба со спуфингом</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rule-urpf"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.4.11. Unicast Reverse Path Forwarding</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-osfp"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.4.12. Пассивное детектирование операционной системы</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rule-ip-opts"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.4.13. Опции IP</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rule-example"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.4.14. Пример</a></span></dt></dl></dd><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-nat"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.5. NAT</a></span></dt><dd><dl><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-nat-theory"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.5.1. Как работает NAT</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-nat+filter"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.5.2. NAT и фильтрация</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-forward"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.5.3. IP forward, проброс пакетов</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-nat-config"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.5.4. Конфигурирование NAT</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-binat"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.5.5. Bidirectional mapping (соответствие 1:1)</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-nonat"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.5.6. Исключения из трансляции</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-nat-state"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.5.7. Проверка состояния правил NAT</a></span></dt></dl></dd><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-rdr"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.6. Перенаправление пакетов, проброс портов</a></span></dt><dd><dl><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rdr-intro"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.6.1. Введение</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rdr+filter"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.6.2. Перенаправление и фильтрация пакетов</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rdr-security"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.6.3. Вопросы безопасности</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rdr-reflection"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.6.4. Перенаправление и отражение</a></span></dt></dl></dd><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-hacks"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.7. Приёмы используемые для упрощения файла <code class="filename">pf.conf(5)</code></a></span></dt><dd><dl><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-hacks-macros"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.7.1. Использование Макросов</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-hacks-lists"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.7.2. Использование списков</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-hacks-grammar"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.1.7.3. Грамматика пакетного фильтра</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-advansed"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.2. Углублённое конфигурирование Пакетного фильтра</a></span></dt><dd><dl><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-options"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.2.1. Опции в пакетном фильтре</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-scrubbing"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.2.2. Нормализация трафика (Scrub)</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-anchors"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.2.3. Anchors</a></span></dt><dd><dl><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-anchors-desc"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.2.3.1. Именованные наборы правил</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-anchors-option"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.2.3.2. Опции якоря</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-anchors-manipulating"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.2.3.3. Управление именованными наборами</a></span></dt></dl></dd><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-queue"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.2.4. Очереди, приоритеты (регулировка полосы пропускания)</a></span></dt><dd><dl><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-queue-queue"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.2.4.1. Очереди</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-queue-sheduler"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.2.4.2. Планировщики</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-queue-conf"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.2.4.3. Конфигурирование очереди</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-queue-ex1"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.2.4.4. Пример 1: небольшая домашняя сеть</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-queue-ex2"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.2.4.5. Пример 2: корпоративная сеть</a></span></dt></dl></dd><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pools"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.2.5. Адресные пулы, балансировка нагрузки</a></span></dt><dd><dl><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pools-nat"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.2.5.1. Адресные пулы NAT</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pools-balance-in"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.2.5.2. Балансировка нагрузки входящего трафика</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pools-balance-out"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.2.5.3. Балансировка нагрузки исходящего трафика</a></span></dt></dl></dd><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-tagging"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.2.6. Маркирование пакетов, фильтрация на основе политик</a></span></dt><dd><dl><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-tagging-assign"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.2.6.1. Присваивание маркера пакетам</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-tagging-check"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.2.6.2. Проверка маркеров</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-tagging-policy"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.2.6.3. Фильтрация на основе политик</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-tagging-ethernet"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.2.6.4. Маркирование кадров ethernet (канальный уровень OSI)</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-addons"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.3. Дополнительные разделы</a></span></dt><dd><dl><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pflog"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.3.1. Журналирование в пакетном фильтре</a></span></dt><dd><dl><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pflog-set"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.3.1.1. Помещение пакетов в журнал</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pflog-read"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.3.1.2. Чтение журнала</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pflog-read-filter"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.3.1.3. Фильтрация журнальных данных</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pflog-syslog"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.3.1.4. Журналирование при помощи <span><strong class="command">syslogd(8)</strong></span></a></span></dt></dl></dd><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-perfomance"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.3.2. Производительность</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-ftp"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.3.3. FTP</a></span></dt><dd><dl><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-ftp-modes"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.3.3.1. Режимы FTP</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-ftp-client"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.3.3.2. FTP клиент за брандмауэром</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-ftp-server"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.3.3.3. FTP сервер защищённый пакетным фильтром запущенным
            непосредственно на нём</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-ftp-server-more"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.3.3.4. FTP сервер защищённый внешним пакетным фильтром с
            запущенным на нём NAT</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-ftp-tftp"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.3.3.5. Проксирование TFTP</a></span></dt></dl></dd><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-authpf"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.3.4. Authpf: авторизация в пакетном фильтре</a></span></dt><dd><dl><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-authpf-conf"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.3.4.1. Конфигурирование <span><strong class="command">authpf(8)</strong></span></a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-authpf-class"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.3.4.2. Создание класса authpf для <code class="filename">/etc/login.conf(5)</code></a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-authpf-log"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.3.4.3. Кто зашёл в систему через <span><strong class="command">authpf(8)</strong></span>?</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-authpf-example"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.3.4.4. Пример</a></span></dt></dl></dd><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-carp+pfsync"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.3.5. <span class="acronym">CARP</span> и pfsync</a></span></dt><dd><dl><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-carp-intro"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.3.5.1. Введение в <span class="acronym">CARP</span></a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-carp-operation"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.3.5.2. Как работает <span class="acronym">CARP</span></a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-carp-config"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.3.5.3. Настройка CARP</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-carp-example"><img name="cover" src="pf_02_files/button-blue.png" alt="[+]">C.2.3.5.4. Пример <span class="acronym">CARP</span></a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pfsync-intro"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.3.5.5. Введение в pfsync(4)</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pfsync-operation"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.3.5.6. Использование с pfsync(4)</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pfsync-config"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.3.5.7. Конфигурирование pfsync</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pfsync-example"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.3.5.8. Пример использования pfsync</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-carp+pfsync-combine"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.3.5.9. Совместное использование <span class="acronym">CARP</span> и
            pfsync для отказоустойчивости</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-carp+pfsync-issues"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.3.5.10. Замечания по использованию <span class="acronym">CARP</span> и pfsync</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-ex1"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.4. Пример: брандмауэр для дома или небольшого офиса</a></span></dt><dd><dl><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-ex1-scenario"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.4.1. Сценарий</a></span></dt><dd><dl><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-ex1-net"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.4.1.1. Сеть</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-ex1-objective"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.4.1.2. Задача</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-ex1-prepare"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.4.1.3. Подготовительные операции</a></span></dt></dl></dd><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-ex1-ruleset"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.4.2. Поэтапное описание правил фильтрации</a></span></dt><dd><dl><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-ex1-ruleset-macro"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.4.2.1. Макросы</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-ex1-ruleset-options"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.4.2.2. Опции</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-ex1-ruleset-scrub"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.4.2.3. Нормализация трафика</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-ex1-ruleset-nat"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.4.2.4. Трансляция NAT</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-ex1-ruleset-rdr"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.4.2.5. Перенаправление</a></span></dt><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-ex1-ruleset-filter"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.4.2.6. Фильтрация</a></span></dt></dl></dd><dt><span class="section"><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-ex1-complete-ruleset"><img name="cover" src="pf_02_files/button-green.png" alt="[+]">C.2.4.3. Полный листинг правил</a></span></dt></dl></dd></dl></div><p>
      Данный раздел на 80% состоит из перевода <a href="http://www.openbsd.org/faq/pf/" target="_top">официальной документации
        по пакетному фильтру <span class="acronym">OpenBSD</span></a>.
      Остальные 20%&nbsp;&#8212; мои добавления из других источников.
    </p><div class="section" lang="ru"><div class="titlepage"><div><div><h3 class="title"><a name="pf-pf.conf-base"></a>C.2.1. Основы конфигурирования пакетного фильтра</h3></div></div></div><p>
        Пакетный фильтр <span class="acronym">OpenBSD</span> при запуске считывает
        правила из конфигурационного файла. По умолчанию это файл
        <code class="filename">/etc/pf.conf(5)</code>. Ниже мы опишем его
        синтаксис.
      </p><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-lists"></a>C.2.1.1. Списки</h4></div></div></div><p>
          Списки позволяют удобным образом задать несколько похожих
          критериев в одном правиле. Например: вместо того, чтобы
          писать по одному правилу на каждый IP-адрес, который мы
          хотим заблокировать, мы можем использовать одно правило и
          передать в него список блокируемых адресов. Когда
          <span><strong class="command">pfctl(8)</strong></span> встречает в конфигурационном
          файле список, он автоматически заменяется на несколько
          правил.  Например:
        </p><div class="informalexample"><pre class="programlisting">block out on fxp0 from { 192.168.0.1, 10.5.32.6 } to any
          </pre></div><p>
          Заменяется на
        </p><div class="informalexample"><pre class="programlisting">block out on fxp0 from 192.168.0.1 to any
block out on fxp0 from 10.5.32.6 to any
          </pre></div><p>
          В одном правиле можно употреблять несколько списков:
        </p><div class="informalexample"><pre class="programlisting">rdr on fxp0 proto tcp from any to any port { 22 80 } -&gt; 192.168.0.6
block out on fxp0 proto { tcp udp } from { 192.168.0.1, 10.5.32.6 } \
        to any port { ssh telnet }
          </pre></div><p>
          списки могут быть вложенными:
        </p><div class="informalexample"><pre class="programlisting">trusted = "{ 192.168.1.2 192.168.5.36 }"
pass in inet proto tcp from { 10.10.0.0/24 $trusted } to port 22
          </pre></div><p>
          Будьте осторожны с отрицаниями в списках. Следующий пример
          демонстрирует распространённую ошибку:
        </p><div class="informalexample"><pre class="programlisting">pass in on fxp0 from { 10.0.0.0/8, !10.1.2.3 }
          </pre></div><p>
          Эта запись означает не &#171;любой адрес из сети 10.0.0.0/8
          кроме 10.1.2.3&#187;, а раскрывается в следующие два правила:
        </p><div class="informalexample"><pre class="programlisting">pass in on fxp0 from 10.0.0.0/8
pass in on fxp0 from !10.1.2.3
          </pre></div><p>
          Если больше нет никаких других ограничивающих правил, такое
          сочетание приведёт к тому, что будут пропущены вообще все
          пакеты кроме пакета с машины 10.1.2.3. Для решения такой задачи лучше
          применять таблицы (см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-tables" title="C.2.1.3. Таблицы">Раздел&nbsp;C.2.1.3, &#171;Таблицы&#187;</a>).
        </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-pf.conf-macro"></a>C.2.1.2. Макросы</h4></div></div></div><p>
          Макросы, это определённые пользователем переменные, которые
          могут содержать IP-адреса, номера портов, имена интерфейсов
          и&nbsp;т.п. Имя макроса подчиняется традиционным для
          большинства языков программирования правилам: начинаться оно
          должно с буквы, а за ней должны идти буквы, цифры или
          символы подчерка. Имя не должно быть зарезервированным
          словом, таким как <code class="code">pass</code>, <code class="code">out</code> или <code class="code">queue</code>.
        </p><div class="informalexample"><pre class="programlisting">ext_if = "fxp0"
block in on $ext_if from any to any
          </pre></div><p>
          Здесь создан макрос <code class="code">ext_if</code>. Когда
          надо сослаться на макрос, его имя начинают со знака <code class="code">$</code>.
        </p><p>
          Макросы могут раскрываться в списки:
        </p><div class="informalexample"><pre class="programlisting">friends = "{ 192.168.1.1, 10.0.2.5, 192.168.43.53 }"
          </pre></div><p>
          Макросы можно вкладывать друг в друга, но, поскольку в
          двойных кавычках макрос указывать нельзя, следует
          использовать следующий синтакс:
        </p><div class="informalexample"><pre class="programlisting">host1 = "192.168.1.1"
host2 = "192.168.1.2"
all_hosts = "{" $host1 $host2 "}"
          </pre></div><p>
          Макрос <code class="code">$all_hosts</code> в этом примере
          будет раскрыт в список <code class="code">{ 192.168.1.1,
            192.168.1.2 }</code>.
        </p><p>
          При помощи команды <span><strong class="command">pfctl(8)</strong></span> можно
          переопределять значения макросов с помощью опции
          <code class="option">-D</code>. Например:
        </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> pfctl -D friends="{ 192.168.1.1, 10.1.2.3 }"
          </pre></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-tables"></a>C.2.1.3. Таблицы</h4></div></div></div><p>
          Таблицы используются для хранения адресов IPv4 и/или IPv6.
          Поиск в них осуществляется очень быстро, они расходуют
          значительно меньше памяти и процессорного времени, чем <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-lists" title="C.2.1.1. Списки">списки</a>. Таблицы, таким
          образом, идеальны для хранения больших массивов адресов,
          поскольку поиск в таблице с 50&nbsp;000 записей происходит не
          на много медленнее, чем в таблице с 50 адресами. Таблицы можно
          использовать следующим образом:
        </p><div class="itemizedlist"><ul type="disc"><li>
            Как IP адреса источника или назначения пакета в правилах
            фильтрации, нормализации (scrub), NAT и правилах
            перенаправления;
          </li><li>
            Как адреса на которые происходит трансляция в правилах NAT;
          </li><li>
            Как адреса на которые происходит перенаправление трафика;
          </li><li>
            Как адреса назначения в правилах фильтрации для опций
            <code class="code">route-to</code>,
            <code class="code">reply-to</code>,
            <code class="code">dup-to</code>,
          </li></ul></div><p>
          Таблицы можно создавать как в конфигурационном файле
          <code class="filename">pf.conf(5)</code>, так и при помощи
          управляющей утилиты <span><strong class="command">pfctl(8)</strong></span>.
        </p><p>
          В конфигуационном файле <code class="filename">pf.conf(5)</code>
          таблицы создаются при помощи директивы <code class="code">table</code>. У таблицы могут быть следующие
          атрибуты:
        </p><div class="variablelist"><dl><dt><span class="term"><code class="code">const</code>, </span><span class="term"><code class="code">persist</code></span></dt><dd>
              Содержимое таблицы не может быть изменено после того, как
              таблица создана. Если этот атрибут отсутствует,
              содержимым таблицы можно манипулровать при помощи
              <span><strong class="command">pfctl(8)</strong></span>.
            
              Указывает ядру, что данную таблицу нельзя удалять из
              памяти даже если на она не упоминается ни в одном
              правиле.  Ели этот атрибут не указан, ядро автоматически
              удалит таблицу из памяти, когда последнее правило
              использующее таблицу будет сброшено.
            </dd></dl></div><p>
          Пример (имя таблицы указывается в угловых скобках <code class="code">&lt;...&gt;</code>):
        </p><div class="informalexample"><pre class="programlisting">table &lt;goodguys&gt; { 192.0.2.0/24 }
table &lt;rfc1918&gt; const { 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }
table &lt;spammers&gt; persist

block in on fxp0 from { &lt;rfc1918&gt;, &lt;spammers&gt; } to any
pass  in on fxp0 from &lt;goodguys&gt; to any
          </pre></div><p>
          Адреса так же можно употреблять с отрицательным знаком (<code class="code">!</code>), или с ключевым словом <code class="code">not</code>:
        </p><div class="informalexample"><pre class="programlisting">table &lt;goodguys&gt; { 192.0.2.0/24, !192.0.2.5 }
          </pre></div><p>
          Таблица <code class="code">&lt;goodguys&gt;</code>, таким
          образом, включает в себя всю сеть 192.0.2.0/24 кроме адреса
          192.0.2.5.
        </p><p>
          Содержимое таблицы можно брать из файла:
        </p><div class="informalexample"><pre class="programlisting">table &lt;spammers&gt; persist file "/etc/spammers"
block in on fxp0 from &lt;spammers&gt; to any
          </pre></div><p>
          Файл <code class="filename">/etc/spammers</code> должен содержать
          IP-адреса и/или блоки сетей в формате CIDR по одному на
          строку. Строки начинающиеся с <code class="code">#</code>
          считаются комментарием и игнорируются.
        </p><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-tables+pfctl"></a>C.2.1.3.1. Манипулирование таблицами с помощью утилиты
          <span><strong class="command">pfctl(8)</strong></span></h5></div></div></div><p>
            Таблицей можно манипулировать при помощи утилиты
            <span><strong class="command">pfctl(8)</strong></span>. Например, следующая команда
            добавляет в таблицу <code class="code">&lt;spammers&gt;</code> ещё одну сеть:
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> pfctl -t spammers -T add 218.70.0.0/16
            </pre></div><p>
            Кроме того, указанная команда создаст таблицу <code class="code">&lt;spammers&gt;</code>, если её ещё нет.
            Чтобы перечислить все вхождения в таблицу можно
            использовать следующую команду:
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> pfctl -t spammers -T show
            </pre></div><p>
            Опция <code class="option">-v</code> может использваться вместе с
            <code class="option">-Tshow</code> для того, чтобы увидеть статистику
            по каждому пункту в таблице:
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> pfctl -t crackers -Ts -v
    222.122.26.172
        Cleared:     Sun Jan 21 18:45:49 2007
        In/Block:    [ Packets: 0                  Bytes: 0                  ]
        In/Pass:     [ Packets: 0                  Bytes: 0                  ]
        Out/Block:   [ Packets: 0                  Bytes: 0                  ]
        Out/Pass:    [ Packets: 0                  Bytes: 0                  ]
    222.175.172.2
        Cleared:     Sun Jan 21 18:45:49 2007
        In/Block:    [ Packets: 0                  Bytes: 0                  ]
        In/Pass:     [ Packets: 0                  Bytes: 0                  ]
        Out/Block:   [ Packets: 0                  Bytes: 0                  ]
        Out/Pass:    [ Packets: 0                  Bytes: 0                  ]
....................
            </pre></div><p>
            Чтобы удалить адрес из таблицы можно использовать команду
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> pfctl -t spammers -T delete 218.70.0.0/16
            </pre></div><p>
            См. так же <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs03.html" title="C.3. Управление пакетным фильтром OpenBSD
      при помощи утилиты pfctl(8)">Раздел&nbsp;C.3, &#171;Управление пакетным фильтром <span class="acronym">OpenBSD</span>
      при помощи утилиты <span><strong class="command">pfctl(8)</strong></span>&#187;</a>.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-address"></a>C.2.1.3.2. Адреса</h5></div></div></div><p>
            Хосты в таблицах можно указывать не только в виде
            IP-адреса, но так же и по имени. В этом случае имена будут
            разрешены и все адреса, соответствующие данному имени,
            попадут в таблицу.  Кроме того, можно указывать имя
            интерфейса или ключевое слово <code class="code">self</code>. В этом случае в таблицу буду
            добавлены все адреса, соответствующие данному интерфейсу, или
            все адреса данной машины (включая кольцевой интерфейс)
            соответственно.
          </p><p>
            Ограничение: адреса 0.0.0.0/0 и 0/0 в таблицах не работают.
            Используйте <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-lists" title="C.2.1.1. Списки">списки</a>.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-address-area"></a>C.2.1.3.3. Соответствие адресам</h5></div></div></div><p>
            При поиске в таблице находится &#171;наиболее
            подходящий&#187; адрес, т.е. сеть с самой большой маской.
            (Наибольшая маска у самой &#171;узкой&#187; сети.)
            Например:
          </p><div class="informalexample"><pre class="programlisting">table &lt;goodguys&gt; { 172.16.0.0/16, !172.16.1.0/24, 172.16.1.100 }
block in on dc0 all
pass  in on dc0 from &lt;goodguys&gt; to any
            </pre></div><p>
            Адрес источника каждого пакета пришедшего через интерфейс
            <code class="code">dc0</code> будет искаться в таблице
            <code class="code">&lt;goodguys&gt;</code>:
          </p><div class="variablelist"><dl><dt><span class="term">172.16.50.5</span></dt><dd>
                Сеть с наибольшей маской&nbsp;&#8212; 172.16.0.0/16;
                пакет соответствует таблице и будет пропущен.
              </dd><dt><span class="term">172.16.1.25</span></dt><dd>
                Сеть с наибольшей маской&nbsp;&#8212; !172.16.1.0/24;
                пакет не соответствует таблице и будет отброшен.
              </dd><dt><span class="term">172.16.1.100</span></dt><dd>
                Сеть с наибольшей маской (а точнее хост)&nbsp;&#8212;
                172.16.1.100; пакет соответствует таблице и будет
                пропущен.
              </dd><dt><span class="term">10.1.4.55</span></dt><dd>
                Подходящих записей в таблице нет. Пакет не
                соответствует таблице и будет отброшен.
              </dd></dl></div></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-filter"></a>C.2.1.4. Фильтрация пакетов</h4></div></div></div><p>
          Фильтрация пакетов заключается в том, что пакеты
          пропускаются или отбрасываются при прохождении через сетевой
          интерфейс в соответствии с правилами. Правила основаны на
          заголовках пакетов сетевого и транспортного уровней модели
          OSI (см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/go01.html#gloss-OSI">OSI</a>). Наиболее часто
          используемые критерии&nbsp;&#8212; адреса источника и
          назначения, номера портов источника и назначения, протоколы.
        </p><p>
          Правила фильтра состоят из критерия и действия, которое надо
          предпринять, если пакет соответствует критерию. Действие
          может быть или <code class="code">block</code> или <code class="code">pass</code>. Правила применяются по очереди
          от первого к последнему, при этом <span class="emphasis"><em>последнее
            правило выигрывает</em></span> если только не встретится
          ключеве слово <code class="code">quick</code>. Таким
          образом, если в самом начале конфигурационного файла задано
          правило &#171;пропускать все пакеты&#187;, или
          &#171;отбрасывать все пакеты&#187;, то это ни что иное, как
          политика по умолчанию&nbsp;&#8212; именно это правило будет
          применено к пакету, который не соответствует ни одному
          правилу ниже по ходу файла.
        </p><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-rule-syntax"></a>C.2.1.4.1. Синтаксис правил</h5></div></div></div><p>
            Ниже приведена упрощённая синтаксическая схема:
          </p><div class="informalexample"><pre class="programlisting">action [direction] [log] [quick] [on interface] [af] [proto protocol] \
    [from src_addr [port src_port]] [to dst_addr [port dst_port]] \
    [flags tcp_flags] [state]
            </pre></div><div class="variablelist"><dl><dt><span class="term"><code class="code">action</code></span></dt><dd>
                Действие может быть либо <code class="code">pass</code>, либо <code class="code">block</code>. Действие <code class="code">pass</code> приводит к тому, что пакет
                возвращается в ядро и направляется на другие правила.
                Действие <code class="code">block</code> приводит к
                тому, что срабатывают настройки из политики <code class="code">block-policy</code> (см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-options" title="C.2.2.1. Опции в пакетном фильтре">Раздел&nbsp;C.2.2.1, &#171;Опции в пакетном фильтре&#187;</a>, или настройки
                определённые при помощи опций
                <code class="code">if-bound</code>). (Назначение данной
                политики состоит в том, чтобы просто отбросить пакет,
                или выслать назад какой-нибудь пакет: TCP с флагом reset
                или ICMP Unreachable.) Политика может быть
                переопределена в правиле: <code class="code">block
                  drop</code> или <code class="code">block
                  return</code>.
              </dd><dt><span class="term"><code class="code">direction</code></span></dt><dd>
                Направление пакета при прохождении через интерфейс:
                <code class="code">in</code> или <code class="code">out</code>.
              </dd><dt><span class="term"><code class="code">log</code></span></dt><dd>
                Указывает, что пакет должен быть журналирован при
                помощи системы <span><strong class="command">pflog(8)</strong></span>. Если
                указаны опции <code class="code">keep&nbsp;state</code>, <code class="code">modulate&nbsp;state</code> или <code class="code">synproxy&nbsp;state</code>&nbsp;&#8212;
                в журнал попадают только пакеты открывшие соединение.
                Если надо, чтобы в журнал попали вообще все пакеты,
                применяйте правило <code class="code">log&nbsp;(all)</code>.
              </dd><dt><span class="term"><code class="code">quick</code></span></dt><dd>
                Если пакет соответствует правилу с ключевым словом
                <code class="code">quick</code>, то данное правило
                считается последним и к пакету немедленно применяется
                действие <code class="code">action</code>. (Т.е. если у
                всех правил будет высталена опция <code class="code">quick</code>, то мы будем иметь дело с
                брандмауэром в котором первое правило выигрывает.)
              </dd><dt><span class="term"><code class="code">interface</code></span></dt><dd><p>
                  Имя сетевого интерфейса, через который проходит
                  пакет, или имя группы сетевых интерфейсов. Группы
                  можно создавать при помощи команды
                  <span><strong class="command">ifconfig(8)</strong></span> (только в
                  <span class="acronym">OpenBSD</span>). Кроме того,
                  некоторые группы создаются ядром автоматически:
                </p><div class="itemizedlist"><ul type="disc"><li>
                    Группа <code class="code">egress</code>, который
                    содержит все интерфейсы, через которые проходят
                    маршруты по умолчанию.
                  </li><li>
                    Группы &#171;клонированных&#187; интерфейсов
                    (<code class="code">ppp</code> или <code class="code">carp</code>).
                  </li></ul></div></dd><dt><span class="term"><code class="code">af</code></span></dt><dd>
                Address family&nbsp;&#8212; <code class="code">inet</code> для адресов IPv4 и <code class="code">inet6</code> для адресов IPv6. Обычно
                пакетный фильтр может определить требуемый протокол по
                указанным в правиле адресам.
              </dd><dt><span class="term"><code class="code">protocol</code></span></dt><dd><p>
                  Протокол транспортного уровня. Возможные варианты:
                </p><div class="itemizedlist"><ul type="disc"><li><code class="code">tcp</code></li><li><code class="code">udp</code></li><li><code class="code">icmp</code></li><li>
                    Имя протокола из файла
                    <code class="filename">/etc/protocols</code>.
                  </li><li>
                    Номер протокола от 0 до 255
                  </li><li>
                    Несколько протоколов описаных при помощи
                    <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-lists" title="C.2.1.1. Списки">списка</a>.
                  </li></ul></div></dd><dt><span class="term"><code class="code">src_addr</code>, <code class="code">dst_addr</code></span></dt><dd><p>
                  Адрес источника или назначения пакета. Возможные
                  варианты:
                </p><div class="itemizedlist"><ul type="disc"><li>
                    Просто одиночный адрес IPv4, или IPv6
                  </li><li>
                    Сеть в формате CIDR
                  </li><li>
                    Полностью разрешённое доменное имя (FQDN), которое
                    будет переведено в IP-адрес через DNS при загрузке
                    правила. Все
                    адреса соответствующие данному имени будут помещены
                    в данное правило.
                  </li><li>
                    Имя интерфейса или группы. Все адреса, закреплённые
                    за интерфейсом, будут подставлены в правило.
                  </li><li>
                    Имя интерфейса с суффиксом <code class="code">/netmask</code> (например <code class="code">/24</code>). Ко всем адресам
                    закреплённым за данным интерфейсом, будет добавлена
                    данная сетевая маска, и полученные сети CIDR будут
                    добавлены в данное правило.
                  </li><li>
                    Имя сетевого интерфейса или группы, взятое в
                    круглые скобки <code class="code">(...)</code>.
                    Данное правило будет автоматически меняться при
                    смене адреса закреплённого за интерфейсом.  Это
                    полезно для DHCP клиентов.
                  </li><li><p>
                      Имя сетевого интерфейса, за которым идёт один из
                      следующих модификаторов:
                    </p><div class="variablelist"><dl><dt><span class="term"><code class="code">:network</code></span></dt><dd>
                          Замещается сетью CIDR закреплённой за данным
                          интерфейсом
                        </dd><dt><span class="term"><code class="code">:broadcast</code></span></dt><dd>
                          Замещается широковещательным адресом
                          закреплённым за данным интерфейсом
                        </dd><dt><span class="term"><code class="code">:peer</code></span></dt><dd>
                          Замещается адресом партнёра для
                          point-to-point интерфейса.
                        </dd></dl></div><p>
                      Кроме того, за именем интерфейса или за любым из
                      перечисленных выше модификаторов, может
                      следовать модификатор <code class="code">:0</code>, указывающий на то,
                      что нас не интересуют алиасы, т.е.
                      дополнительные адреса, котрые можно добавить к
                      сетевому интерфейсу (см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/ch06s15.html" title="6.15. Знание как и когда устанавливать или удалять алиасы сетевого интерфейса">Раздел&nbsp;6.15, &#171;Знание как и когда устанавливать или удалять алиасы сетевого интерфейса&#187;</a>).  Например: <code class="code">fxp0:network:0</code>.
                    </p></li><li><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-tables" title="C.2.1.3. Таблицы">Таблица</a></li><li>
                    Любая из приведённых выше конструкций с символом
                    отрицания&nbsp;&#8212; <code class="code">!</code>.
                  </li><li>
                    Перечень конструкций с использованием <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-lists" title="C.2.1.1. Списки">списка</a>.
                  </li><li>
                    Ключевое слово <code class="code">any</code>,
                    означающее все адреса.
                  </li><li>
                    Ключевое слово <code class="code">all</code>,
                    которое является эквивалентом конструкции <code class="code">from any to any</code>.
                  </li></ul></div></dd><dt><span class="term"><code class="code">src_port</code>, <code class="code">dst_port</code></span></dt><dd><p>
                  </p><p>
                    Порт источника или назначения в заголовке
                    транспортного уровня. Возможны следующие варианты:
                  </p><p>
                  </p><div class="itemizedlist"><ul type="disc"><li>
                      Число от 1 до 65535
                    </li><li>
                      Имя протокола из файла
                      <code class="filename">/etc/services</code>.
                    </li><li>
                      Перечень конструкций с использованием <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-lists" title="C.2.1.1. Списки">списка</a>.
                    </li><li><p>
                        Диапазоны портов с применением следующих
                        операторов:
                      </p><div class="variablelist"><dl><dt><span class="term"><code class="code">!=</code></span></dt><dd>
                            Неравно
                          </dd><dt><span class="term"><code class="code">&lt;</code></span></dt><dd>
                            Меньше чем
                          </dd><dt><span class="term"><code class="code">&gt;</code></span></dt><dd>
                            Больше чем
                          </dd><dt><span class="term"><code class="code">&lt;=</code></span></dt><dd>
                            Меньше или равно
                          </dd><dt><span class="term"><code class="code">&gt;=</code></span></dt><dd>
                            Больше или равно
                          </dd><dt><span class="term"><code class="code">&gt;&lt;</code></span></dt><dd>
                            Диапазон (исключающий концы)
                          </dd><dt><span class="term"><code class="code">&lt;&gt;</code></span></dt><dd>
                            Инвертированный диапазон
                          </dd><dt><span class="term"><code class="code">:</code></span></dt><dd>
                            Диапазон включающий концы
                          </dd></dl></div><p>
                        Последние три оператора бинарные (принимают
                        два аргумента). При этом <code class="code">&lt;&gt;</code> и <code class="code">&gt;&lt;</code> не включают
                        аргументы в диапазон, а <code class="code">:</code> включает.
                      </p></li></ul></div><p>
                </p></dd><dt><span class="term"><code class="code">tcp_flags</code></span></dt><dd>
                Указывает какие флаги TCP должны быть выставлены в
                пакете, если указано <code class="code">proto&nbsp;tcp</code>. Флаги задаются
                как <code class="code">flags&nbsp;check/mask</code>.
                <code class="code">mask</code>&nbsp;&#8212; список
                проверяемых флагов, <code class="code">check</code>&nbsp;&#8212; список
                флагов, которые должны быть включены.  Например
                директива <code class="code">flags&nbsp;S/SA</code>
                означает, что мы ищем пакет у которого выключен флаг
                ACK, и включён флаг SYN, а остальные флаги нас не
                интересуют.
              </dd><dt><span class="term"><code class="code">state</code></span></dt><dd><p>
                  </p><p>
                    Указывает сохраняется ли данным правилом
                    информация о состоянии соединения. Возможные
                    варианты:
                  </p><p>
                  </p><div class="variablelist"><dl><dt><span class="term"><code class="code">keep state</code></span></dt><dd>
                        Работает для протоколов TCP, UDP и ICMP
                      </dd><dt><span class="term"><code class="code">modulate state</code></span></dt><dd>
                        Работает только с TCP. Пакетный фильтр
                        генерирует устойчивые к атакам номера
                        последовательностей (ISN) для пакетов
                        соответствующих данному правилу.
                      </dd><dt><span class="term"><code class="code">synproxy state</code></span></dt><dd>
                        Пробрасывает входящие пакеты TCP помогая
                        защитить серверы от SYN флуда (когда атакующий
                        посылает большое количество пакетов с флагом
                        SYN, открывающих соединение, тем самым пытаясь
                        организовать <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/go01.html#gloss-DOS">DOS</a> атаку на
                        сервер). Данная опция включает в себя
                        функционал опций <code class="code">keep&nbsp;state</code> и <code class="code">modulate&nbsp;state</code>.
                      </dd></dl></div><p>
                </p></dd></dl></div><p>
            Полная синтаксическая схема приведена в справочной странице
            <span><strong class="command">man(1)</strong></span> по
            <code class="filename">pf.conf(5)</code>. В неё входят не упомянутые
            здесь опции. Если вы только изучаете пакетный фильтр,
            возможно вам стоит пропустить дальнейший список и перейти к
            разделу <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rule-politic" title="C.2.1.4.2. Политика">Раздел&nbsp;C.2.1.4.2, &#171;Политика&#187;</a>, или
            просто кратко ознакомиться с возможностями фильтра.
          </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Warning" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Внимание]" src="pf_02_files/warning.png"></td><th align="left">Внимание</th></tr><tr><td valign="top" align="left">
            В разных системах <span class="acronym">BSD</span> присутствуют разные
            версии пакетного фильтра и не все возможности описанные
            здесь могут быть реализованы в вашей системе. Больше того,
            не все возможности описанные в вашем
            <span><strong class="command">man</strong></span> по <code class="filename">pf.conf(5)</code>
            реализованы в вашей системе, так как при портировании
            <span><strong class="command">man</strong></span>, увы, не редактируют.
          </td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Замечание]" src="pf_02_files/note.png"></td><th align="left">Замечание</th></tr><tr><td valign="top" align="left">
            Имейте в виду, что данный ниже список носит ознакомительный
            характер и перед применением вам следует справиться о
            синтаксисе в вашей странице <span><strong class="command">man</strong></span> по
            <code class="filename">pf.conf(5)</code></td></tr></tbody></table></div><div class="variablelist"><dl><dt><span class="term"><code class="code">user &lt;user&gt;</code></span></dt><dd>
                Пакет соответствует правилу, если он принадлежит сокету,
                которым владеет <code class="code">&lt;user&gt;</code>.
              </dd><dt><span class="term"><code class="code">group &lt;group&gt;;</code></span></dt><dd>
                Аналогично.
              </dd><dt><span class="term"><code class="code">icmp-type &lt;type&gt; code &lt;code&gt;</code></span></dt><dd>
                Правило соответствует пакету <span class="acronym">ICMP</span> с
                указанным типом и кодом.
              </dd><dt><span class="term"><code class="code">icmp6-type &lt;type&gt; code &lt;code&gt;</code></span></dt><dd>
                Аналогично.
              </dd><dt><span class="term"><code class="code">tos &lt;string|number&gt;</code></span></dt><dd><p>
                  Правило соответствует пакетам с указанным значением
                  <span class="acronym">TOS</span>. Возможные варианты: <code class="code">lowdelay</code>, <code class="code">throughput</code>, <code class="code">reliability</code> или десятичное или
                  шестнадцатеричное значение. Например, следующие строки
                  эквивалентны:
                </p><div class="informalexample"><pre class="programlisting">pass all tos lowdelay
pass all tos 0x10
pass all tos 16
                  </pre></div></dd><dt><span class="term"><code class="code">allow-opts</code></span></dt><dd>
                Обычно, пакеты содержашие опции <span class="acronym">IP</span>
                блокируются. Данный критерий позволяет изменить это
                поведение.
              </dd><dt><span class="term"><code class="code">label &lt;string&gt;</code></span></dt><dd><p>
                  Правило метится при помощи метки <code class="code">&lt;string&gt;</code>. Просмотреть
                  статистику по помеченным правилам можно при помощи
                  команды <span><strong class="command">pfctl(8)</strong></span> с опцией
                  <code class="option">-s label</code>. Метки можно использовать для
                  предотвращения оптимизации, что важно при написании
                  биллинговой системы.
                </p><p>
                  При объявлении меток можно использовать следующие
                  макросы:
                </p><div class="variablelist"><dl><dt><span class="term"><code class="code">$if</code></span></dt><dd>
                      интерфейс
                    </dd><dt><span class="term"><code class="code">$srcaddr</code></span></dt><dd>
                      адрес источника
                    </dd><dt><span class="term"><code class="code">$dstaddr</code></span></dt><dd>
                      адрес назначения
                    </dd><dt><span class="term"><code class="code">$srcport</code></span></dt><dd>
                      порт источника
                    </dd><dt><span class="term"><code class="code">$dstport</code></span></dt><dd>
                      порт назначения
                    </dd><dt><span class="term"><code class="code">$proto</code></span></dt><dd>
                      название протокола
                    </dd><dt><span class="term"><code class="code">$nr</code></span></dt><dd>
                      номер правила
                    </dd></dl></div><p>
                  Например:
                </p><div class="informalexample"><pre class="programlisting">ips = "{ 1.2.3.4, 1.2.3.5 }"
pass in proto tcp from any to $ips \
     port &gt; 1023 label "$dstaddr:$dstport"
                  </pre></div><p>
                  эквивалентно
                </p><div class="informalexample"><pre class="programlisting">pass in proto tcp from any to 1.2.3.4 \
      port &gt; 1023 label "1.2.3.4:&gt;1023"
pass in proto tcp from any to 1.2.3.5 \
      port &gt; 1023 label "1.2.3.5:&gt;1023"
                  </pre></div></dd><dt><span class="term"><code class="code">queue &lt;queue&gt; | (&lt;queue&gt;, &lt;queue&gt;)</code></span></dt><dd>
                Ассоциация трафика с некоторой очередью. См. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-queue" title="C.2.2.4. Очереди, приоритеты (регулировка полосы пропускания)">Раздел&nbsp;C.2.2.4, &#171;Очереди, приоритеты (регулировка полосы пропускания)&#187;</a></dd><dt><span class="term"><code class="code">tag &lt;string&gt;</code></span></dt><dd>
                Присваивание пакету некоторого маркера. См. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-tagging-assign" title="C.2.2.6.1. Присваивание маркера пакетам">Раздел&nbsp;C.2.2.6.1, &#171;Присваивание маркера пакетам&#187;</a></dd><dt><span class="term"><code class="code">tagged &lt;string&gt;</code></span></dt><dd>
                Ссылка на помеченный пакет. См. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-tagging-check" title="C.2.2.6.2. Проверка маркеров">Раздел&nbsp;C.2.2.6.2, &#171;Проверка маркеров&#187;</a></dd><dt><span class="term"><code class="code">fastroute</code></span></dt><dd>
                Пакет будет маршрутизирован обычным образом
              </dd><dt><span class="term"><code class="code">route-to &lt;interface&gt; [nexthop]</code></span></dt><dd>
                Указывается интерфейс через который надо выпустить пакет
                и, необязательно, адрес следующего шлюза.  Правило
                применяется к пакетам начинающим соединение и не
                относится к ответам.
              </dd><dt><span class="term"><code class="code">reply-to &lt;interface&gt; [nexthop]</code></span></dt><dd>
                Указывает через какой интерфейс надо испускать ответные
                пакеты. Имеет смысл только при условии использования
                таблицы состояний соединений. Можно использовать на
                шлюзах с несколькими внешними интефейсами для
                распределения нагрузки.
              </dd><dt><span class="term"><code class="code">dup-to &lt;interface&gt; [nexthop]</code></span></dt><dd>
                Создаёт копию пакета и маршрутизирует её как если бы
                была применена опция <code class="code">route-to</code>. Оригинальный пакет
                маршрутизируется обычным образом.
              </dd><dt><span class="term"><code class="code">rtable &lt;number&gt;</code></span></dt><dd>
                Ссылка на некоторую конкретную таблицу маршрутизации.
                Имеет смысл только до того, как осуществится
                маршрутизация, т.е. для входящего трафика.
              </dd><dt><span class="term"><code class="code">probability &lt;num&gt;</code></span></dt><dd><p>
                  Вероятность срабатывания правила. Задаётся как дробь от
                  0 до 1 или в процентах. Например, следующее правило
                  отбрасывает пакеты ICMP с вероятностью 20%:
                </p><div class="informalexample"><pre class="programlisting">block in proto icmp probability 20%
                  </pre></div></dd></dl></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-rule-politic"></a>C.2.1.4.2. Политика</h5></div></div></div><p>
            Рекомендуемая практика при написании
            брандмауэров&nbsp;&#8212; делать политику &#171;default
            deny&#187;, т.е. по умолчанию отбрасывать
            <span class="emphasis"><em>все</em></span> пакеты, а потом пропускать
            некоторые разрешённые пакеты. Для создания политики
            &#171;default deny&#187; надо сделать следующие первые два
            правила:
          </p><div class="informalexample"><pre class="programlisting">block in  all
block out all
            </pre></div><p>
            Эти правила блокируют весь трафик на всех интерфейсах вне
            зависимости от направления.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-rule-pass"></a>C.2.1.4.3. Пропускаем трафик</h5></div></div></div><p>
            Теперь нам надо явно разрешить прохождение трафика, чтобы
            он не был заблокирован политикой. Здесь понадобятся такие
            критерии как номера портов источника и назначения, адреса
            источника и назначения, протоколы. Правила должны быть
            настолько строгими, насколько это возможно, для того,
            чтобы через брандмауэр проходил только нужный трафик.
          </p><p>
            Например:
          </p><div class="informalexample"><pre class="programlisting"># Пропускать трафик из локальной сети (192.168.0.0/24) идущий через
# интерфейс dc0 на машину OpenBSD (FreeBSD, NetBSD) с адресом 192.168.0.1,
# а так же выпускать ответный трафик.
pass in  on dc0 from 192.168.0.0/24 to 192.168.0.1
pass out on dc0 from 192.168.0.1 to 192.168.0.0/24

# Пропускать TCP трафик на интерфейсе fxp0 направленный на web сервер
# запущенный на нашей OpenBSD (FreeBSD, NetBSD) машине. Имя интерфейса
# использовано в качестве адреса назначения, поэтому правилу
# соответствуют только пакеты направленные к нам.
pass in on fxp0 proto tcp from any to fxp0 port www
            </pre></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-rule-quick"></a>C.2.1.4.4. Ключевое слово <code class="code">quick</code></h5></div></div></div><p>
            Как было замечено выше, пакеты проходят через все правила
            от начала до конца. Пакет, который пометился правилом как
            проходящий (<code class="code">pass</code>) может
            многократно сменить действие с <code class="code">pass</code> на <code class="code">block</code> и обратно, в процессе
            прохождения через правила. <span class="emphasis"><em>Последнее правило
              выигрывает</em></span>, если только пакет не встретит
            правило с ключевым словом <code class="code">quick</code>, которое останавливает
            прохождение пакета по правилам.
          </p><p>
            Вот пара примеров:
          </p><p><b>Неправильный пример:&nbsp;</b></p><div class="informalexample"><pre class="programlisting">block in on fxp0 proto tcp from any to any port ssh
pass  in all
              </pre></div><p>
            В этом случае правило <code class="code">block</code>
            возможно применяется к пакетам ssh, но в итоге никогда не
            срабатывает, так как дальше идёт правило, которое
            разрешает весь трафик.
          </p><p><b>Правильный пример:&nbsp;</b></p><div class="informalexample"><pre class="programlisting">block in quick on fxp0 proto tcp from any to any port ssh
pass  in all
              </pre></div><p>
            В данном примере трафик ssh будет отброшен немедленно,
            так как встретилось ключевое слово <code class="code">quick</code>, и все другие правила
            относящиеся к трафику ssh будут проигноророваны.
          </p><p><b>Неоднозначный пример:&nbsp;</b></p><div class="informalexample"><pre class="programlisting">pass  in all
block in on fxp0 proto tcp from any to any port ssh
              </pre></div><p>
            Такие два правила возможно приведут к блокированию
            трафика, а может быть и нет. В зависимости от того, какие
            правила окажутся ниже по тексту.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-rule-state"></a>C.2.1.4.5. Отслеживание состояния соединения</h5></div></div></div><p>
            Одна из важных возможностей пакетного
            фильтра&nbsp;&#8212; отслеживание состояния соединений
            (&#171;stateful inspection&#187;). Stateful inspection
            возможна благодаря возможности пакетного фильтра
            отслеживать состояния сетевых соединений. Состояние
            каждого соединения хранится в таблице состояний. Пакетный
            фильтр может быстро определить принадлежит ли пакет уже
            открытому соединению. Если пакет принадлежит уже открытому
            соединению, то его пропускают, не направляя на другие
            фильтрующие правила.
          </p><p>
            Использование таблицы состояний имеет много преимуществ:
            от упрощения правил фильтрации, до увеличения
            производительности брандмауэра. Пакетный фильтр может
            определить принадлежность пакета открытому соединению
            независимо от направления в котором идёт пакет. Это
            освобождает от необходимости написания правил пропускающих
            ответный трафик. А поскольку пакет не направляется ни на
            какие правила, время прохождения пакета через брандмауэр
            существенно уменьшается.
          </p><p>
            Если в правиле присутсвует опция <code class="code">keep&nbsp;state</code>, первый пакет
            соответствующий правилу создаёт запись в таблице состояний
            связывающую источник и получателя пакета. Теперь не только
            пакеты идущие от источника к получателю, но и обратные
            пакеты будут соответствовать созданной записи в таблице
            состояний и не будут подвергаться проверке. Например:
          </p><div class="informalexample"><pre class="programlisting">pass out on fxp0 proto tcp from any to any keep state
            </pre></div><p>
            Это правило разрешает любой исходящий трафик на
            интерфейсе <code class="code">fxp0</code>, а так же
            разрешает прохождение всего ответного трафика через
            брандмауэр. Функция <code class="code">keep&nbsp;state</code> замечательна так же
            тем, что значительно улучшает производительность
            брандмауэра, так как поиск в таблице состояний намного
            быстрее чем проверка пакета при помощи правил фильтрации.
          </p><p>
            Функция <code class="code">modulate&nbsp;state</code>
            работает так же как <code class="code">keep&nbsp;state</code>, но применима
            только к пакетам TCP. При использовании <code class="code">modulate&nbsp;state</code>, начальный
            номер последовательности (ISN) исходящих соединений
            выбирается случайным образом. Это полезно для защиты
            соединений инициализированных операционными системами,
            проделывающими более слабую работу по выбору номера ISN.
            Начиная с <span class="acronym">OpenBSD</span>&nbsp;3.5 правило
            <code class="code">modulate&nbsp;state</code> можно
            употреблять не только для протокола TCP (рандомизация
            последовательности при этом будет работать для TCP
            протокола, а для UDP и ICMP будет работать <code class="code">keep&nbsp;state</code>).
          </p><p>
            Сохранять состояние TCP, UDP и ICMP трафика, и
            рандомизировать ISN в TCP:
          </p><div class="informalexample"><pre class="programlisting">pass out on fxp0 proto { tcp, udp, icmp } from any to any modulate state
            </pre></div><p>
            Другое преимущество таблицы состояний состоит в том, что
            трафик ICMP соответствующий открытому соединению тоже
            пропускается через брандмауэр. Например: если <code class="code">keep&nbsp;state</code> указан для
            соединения TCP, и получено сообщение ICMP source-quench
            относящееся к данному соединению TCP, то оно будет
            пропущено через брандмауэр (ICMP пакет source-quench
            уменьшает скорость отправки пакетов через маршрутизатор и
            отсылается маршрутизатором или конечным хостом если,
            например, у них переполнен буфер).
          </p><p>
            Область действия записи в таблице состояния ограничивается
            задаваемой глобально опцией <code class="code">state-policy</code> (см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-options" title="C.2.2.1. Опции в пакетном фильтре">Раздел&nbsp;C.2.2.1, &#171;Опции в пакетном фильтре&#187;</a>, или при помощи опций
            <code class="code">if-bound</code>), <code class="code">group-bound</code> и <code class="code">floating</code>, задаваемых непосредственно
            в правилах. Они имеют то же значение, что и заданные
            глобально политики <code class="code">state-policy</code>.
            Пример:
          </p><div class="informalexample"><pre class="programlisting">pass out on fxp0 proto { tcp, udp, icmp } from any \
  to any modulate state (if-bound)
            </pre></div><p>
            Это правило гласит, что пакет будет соответствовать записи в
            таблице состояний только если он идёт через интерфейс <code class="code">fxp0</code>.
          </p><p>
            Правила <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-rdr" title="C.2.1.6. Перенаправление пакетов, проброс портов"><code class="code">nat</code>, <code class="code">binat</code></a> и <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-rdr" title="C.2.1.6. Перенаправление пакетов, проброс портов"><code class="code">rdr</code></a> тоже создают записи в
            таблице состояний.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-rule-udp-state"></a>C.2.1.4.6. Хранение состояний для UDP</h5></div></div></div><p>
            Кто-то может подумать, что для протокола UDP нельзя делать
            записи в таблице состояний, так как это
            &#171;stateless&#187; протокол. Однако пакетный фильтр
            может отслеживать его состояния. Несмотря на отсутствие
            &#171;стартового&#187; пакета, пакетный фильтр следит за
            пакетами на основании таймаутов и номеров портов источника и
            назначения. По достижении таймаута таблица состояний
            очищается от соответствующей записи.  Величину таймаута можно
            задать в разделе &#171;опции&#187;
            <code class="filename">pf.conf</code>, см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-options" title="C.2.2.1. Опции в пакетном фильтре">Раздел&nbsp;C.2.2.1, &#171;Опции в пакетном фильтре&#187;</a>
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-rule-state-opts"></a>C.2.1.4.7. Опции таблицы состояний</h5></div></div></div><p>
            Можно использовать некоторые опции для управления поведением
            записей в таблице состояний, созданных при помощи команд
            <code class="code">keep&nbsp;state</code>, <code class="code">modulate&nbsp;state</code> или <code class="code">synproxy&nbsp;state</code>. Вот список этих
            опций:
          </p><div class="variablelist"><dl><dt><span class="term"><code class="code">max</code> number</span></dt><dd>
                  Ограничение максимального количества записей в таблице
                  состояний, которое может сделать данное правило. По
                  достижении этого предела, будет отброшен любой пакет,
                  который должен был бы завести новую запись в таблице
                  состояний. Пакеты будут отбрасываться до тех пор, пока
                  число записей в таблице состояний не уменьшится.
                </dd><dt><span class="term"><code class="code">source-track</code></span></dt><dd><p>
                  Эта опция даёт возможность отслеживать количество
                  записей в таблице состояний в пересчёте на каждый
                  адрес источника. Возможные форматы опции:
                </p><div class="itemizedlist"><ul type="disc"><li><code class="code">source-track&nbsp;rule</code>&nbsp;&#8212;
                    Максимальное количество записей в таблице
                    состояний созданных данным правилом ограничивается
                    опциями <code class="code">max-src-nodes</code> и
                    <code class="code">max-src-states</code>,
                    заданными в этом правиле. Счётчики заводятся не
                    глобальные, а локальные.
                  </li><li><code class="code">source-track&nbsp;global</code>&nbsp;&#8212;
                    То же что и в предыдущем слуаче, но счётчики
                    ведутся глобально. При этом каждое правило может
                    иметь свои пределы <code class="code">max-src-nodes</code> и <code class="code">max-src-states</code>, однако
                    счётчики будут общими для всех правил.
                  </li></ul></div><p>
                  Общее количество адресов источников, для которых
                  осуществляется глобальный контроль количества строк
                  в таблице состояний, ограничивается при помощи опции
                  <code class="code">src-nodes</code>. (См. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-options" title="C.2.2.1. Опции в пакетном фильтре">Раздел&nbsp;C.2.2.1, &#171;Опции в пакетном фильтре&#187;</a>)
                </p></dd><dt><span class="term"><code class="code">max-src-nodes</code> number</span></dt><dd>
                При использовании опции <code class="code">source-track</code> опция <code class="code">max-src-nodes</code> ограничивает
                количество IP-адресов с которых можно одновременно
                открыть соединения.
              </dd><dt><span class="term"><code class="code">max-src-states</code> number</span></dt><dd>
                При использовании опции <code class="code">source-track</code> опция <code class="code">max-src-states</code> ограничивает
                количество соединений с одного IP-адреса.
              </dd></dl></div><p>
            Например:
          </p><div class="informalexample"><pre class="programlisting">pass in on $ext_if proto tcp to $web_server \
    port www flags S/SA keep state \
    (max 200, source-track rule, max-src-nodes 100, max-src-states 3)
            </pre></div><p>
            Это правило означает следующее:
          </p><div class="itemizedlist"><ul type="disc"><li>
              Данное правило может создать не более 200 записей в
              таблице состояний.
            </li><li>
              Включается отслеживание исходящих IP-адресов.
              Ограничения действуют только на данное правило.
            </li><li>
              Максимальное количество одновременно подключённых к
              серверу IP-адресов&nbsp;&#8212; 100 штук.
            </li><li>
              С одного IP адреса можно открыть не более 3-х соединений.
            </li></ul></div><p>
            Отдельные ограничения можно ввести для TCP соединений
            прошедших тройное рукопожатие (см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apbs01.html#TCP-open" title="B.1.4.3.2. Открытие соединения TCP, тройное рукопожатие">Раздел&nbsp;B.1.4.3.2, &#171;Открытие соединения TCP, тройное рукопожатие&#187;</a>):
          </p><div class="variablelist"><dl><dt><span class="term"><code class="code">max-src-conn</code> number</span></dt><dd>
                Ограничение максимального количества TCP соединений
                прошедших тройное рукопожатие, которые можно открыть с
                одного IP-адреса.
              </dd><dt><span class="term"><code class="code">max-src-conn-rate</code> number / interval</span></dt><dd>
                Ограничение скорости с которой можно открывать новые
                соединения. Задаётся количество соединений за интервал
                времени.
              </dd></dl></div><p>
            Обе опции автоматически включают опцию <code class="code">state-track rule</code> и не совместимы с
            <code class="code">state-track global</code>.
          </p><p>
            В комбинации с данными опциями можно употреблять более
            агрессивные опции, для &#171;наказания&#187;
            &#171;провинившихся&#187;.
          </p><div class="variablelist"><dl><dt><span class="term"><code class="code">overload</code> &lt;table&gt;</span></dt><dd>
                При превышении лимитов занести адрес источника в
                таблицу.
              </dd><dt><span class="term"><code class="code">flash</code> [global]</span></dt><dd>
                Уничтожить все записи в таблице состояний
                соответствующие соединениям с данного IP-адреса. При
                указании опции <code class="code">global</code>
                записи в таблице состояний сбрасываются независимо от
                того, какое правило её создало.
              </dd></dl></div><p>
            Пример:
          </p><div class="informalexample"><pre class="programlisting">table &lt;abusive_hosts&gt; persist
block in quick from &lt;abusive_hosts&gt;

pass in on $ext_if proto tcp to $web_server \
    port www flags S/SA keep state \
    (max-src-conn 100, max-src-conn-rate 15/5, overload &lt;abusive_hosts&gt; flush)
            </pre></div><p>
            Эти правила делают следующее:
          </p><div class="itemizedlist"><ul type="disc"><li>
              Максимальное количество соединений с одного
              IP-адреса&nbsp;&#8212; 100 штук.
            </li><li>
              Скорость с которой можно делать новые соединения
              ограничена&nbsp;&#8212; не более 15 соединений за 5
              секунд.
            </li><li>
              Адреса хостов, которые превысили эти лимиты заносятся в
              таблицу &lt;abusive_hosts&gt;. Это приведёт к тому, что
              данные адреса больше не смогут открывать соединения к
              серверу (см. правило <code class="code">block</code>).
            </li><li>
              Для каждого &#171;проштрафившегося&#187; адреса
              удаляются все записи из таблицы состояний появившиеся
              там благодаря данному правилу.
            </li></ul></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-rule-flags"></a>C.2.1.4.8. TCP флаги</h5></div></div></div><p>
            При открытии соединения TCP пакетный фильтр должен изучить
            флаги TCP выставленные в заголовке пакета. Описание флагов
            дано в <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apbs01.html#tcp-flags" title="Таблица B.3. Флаги TCP">Таблица&nbsp;B.3, &#171;Флаги TCP&#187;</a>. Для изучения флагов
            применяется ключевое слово <code class="code">flags&nbsp;check/mask</code>. <code class="code">mask</code> указывает фильтру, что он
            изучает только указанные в этом поле флаги, а поле <code class="code">check</code> указывает какие флаги должны
            быть включены, чтобы удовлетворять данному правилу.
          </p><div class="informalexample"><pre class="programlisting">pass in on fxp0 proto tcp from any to any port ssh flags S/SA
            </pre></div><p>
            Приведённое правило пропускает весь TCP трафик c
            установленным флагом SYN, при этом изучаются флаги SYN и
            ACK. Пакет с флагами SYN и ECE будет пропущен данным
            правилом, а пакет в котором выставлены флаги SYN и ACK или
            просто ACK не будет пропущен.
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Замечание]" src="pf_02_files/note.png"></td><th align="left">Замечание</th></tr><tr><td valign="top" align="left">
            В старых версиях поддерживался синтаксис <code class="code">...&nbsp;flags&nbsp;S</code>, в новых
            версиях фильтра маска всегда должна указываться.
          </td></tr></tbody></table></div><p>
            Часто флаги указываются вместе с правилом <code class="code">keep&nbsp;state</code> для создания записи
            в таблице состояний:
          </p><div class="informalexample"><pre class="programlisting">pass out on fxp0 proto tcp all flags S/SA keep state
            </pre></div><p>
            Данное правило разрешает исходящие соединения начинающиеся
            с пакета в котором выставленн флаг SYN, а флага ACK нет.
          </p><p>
            Будьте внимательны при использовании флагов. Понимайте что
            вы делаете и зачем, особенно когда пользуетесь чьими-то
            советами. Некоторые люди предлагают открывать соединения
            если указан флаг SYN <span class="emphasis"><em>и никакой
              другой</em></span>:
          </p><div class="informalexample"><pre class="programlisting">. . . flags S/FSRPAUEW  плохая идея!!
            </pre></div><p>
            Теоретически первый пакет должен содержать флаг SYN и
            никакой другой, однако некоторые хосты выставляют флаг ECN
            и будут отвергнуты данным правилом. Более разумным будет
            следующее правило:
          </p><div class="informalexample"><pre class="programlisting">. . . flags S/SAFR
            </pre></div><p>
            Это практично и безопасно, однако в этом нет
            необходимости, если трафик был нормализован при помощи
            <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-scrubbing" title="C.2.2.2. Нормализация трафика (Scrub)">scrub</a>. Процесс
            нормализации трафика заставляет пакетный фильтр отбрасывать
            пакеты с неправильными сочетаниями флагов (вроде SYN+RST)
            или подозрительным счетанием (SYN+FIN). Крайне желательно
            всегда подвергать трафик нормализации:
          </p><div class="informalexample"><pre class="programlisting">scrub in on fxp0
.
.
.
pass in on fxp0 proto tcp from any to any port ssh flags S/SA keep state
            </pre></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-rule-synproxy"></a>C.2.1.4.9. TCP SYN proxy</h5></div></div></div><p>
            В обычной ситуации клиент выполняет тройное рукопожатие с
            сервером (см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apbs01.html#TCP-open" title="B.1.4.3.2. Открытие соединения TCP, тройное рукопожатие">Раздел&nbsp;B.1.4.3.2, &#171;Открытие соединения TCP, тройное рукопожатие&#187;</a>). Пакетный фильтр
            умеет выполнять в этой процедуре функцию посредника. При
            этом фильтр выполняет тройное рукопожатие с клиентом, затем
            проводит рукопожатие с сервером, и уже после этого начинает
            пробрасывать пакеты между клиентом и сервером. Этот метод
            позволяет избежать TCP SYN флуда (разновидность сетевой DOS
            атаки, когда клиент забрасывает сервер заявками на открытие
            соединения, но соединение не открывает. В результате у
            сервера могут исчерпаться сокеты.  см. так же <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/go01.html#gloss-DOS">DOS атака</a>).
          </p><p>
            Проксирование рукопожатия проводится при помощи ключевого
            слова <code class="code">synproxy&nbsp;state</code>:
          </p><div class="informalexample"><pre class="programlisting">pass in on $ext_if proto tcp from any to $web_server port www \
    flags S/SA synproxy state
            </pre></div><p>
            В этом примере проксируется входящее соединение к
            web-серверу.
          </p><p>
            <code class="code">synproxy&nbsp;state</code> включает в
            себя функционал <code class="code">keep&nbsp;state</code>
            и <code class="code">modulate&nbsp;state</code>.
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Замечание]" src="pf_02_files/note.png"></td><th align="left">Замечание</th></tr><tr><td valign="top" align="left">
            SYN proxy невозможен, если пакетный фильтр работает на
            мосту. (См. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/go01.html#gloss-bridge">bridge</a>.)
          </td></tr></tbody></table></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-rule-spoofing"></a>C.2.1.4.10. Борьба со спуфингом</h5></div></div></div><p>
            IP-спуфинг&nbsp;&#8212; подделка исходящих адресов в
            заголовке IP пакета (см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/go01.html#gloss-spoofing">spoofing</a>).
          </p><p>
            Пакетный фильтр может осуществлять защиту от спуфинга при
            помощи правил начинающихся с ключевого слова <code class="code">antispoof</code>:
          </p><div class="informalexample"><pre class="programlisting">antispoof [log] [quick] for interface [af]
            </pre></div><div class="variablelist"><dl><dt><span class="term"><code class="code">log</code></span></dt><dd>
                Пакеты будут помещаться в журнал при помощи
                <span><strong class="command">pflogd(8)</strong></span></dd><dt><span class="term"><code class="code">quick</code></span></dt><dd>
                Пакет соответствующий правилу будет немедленно отброшен
                и не пойдёт на другие правила, которые могут его
                пропустить.
              </dd><dt><span class="term"><code class="code">interface</code></span></dt><dd>
                Сетевой интерфейс на котором производится защита от
                спуфинга (здесь может быть указан <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-lists" title="C.2.1.1. Списки">список</a>)
              </dd><dt><span class="term"><code class="code">af</code></span></dt><dd>
                Протокол для которого осуществляется защита. Может
                быть как IPv4, так и IPv6. Соответственно <code class="code">inet</code> и <code class="code">inet6</code>.
              </dd></dl></div><p>
            Пример:
          </p><div class="informalexample"><pre class="programlisting">antispoof for fxp0 inet
            </pre></div><p>
            Каждое правило <code class="code">antispoof</code>
            превращается в два правила фильтра. Например, если за
            интерфейсом fxp0 закреплён адрес 10.0.0.1 и сетевая маска
            255.255.255.0 (т.е. /24), то предыдущее правило
            превратится в следующие два правила:
          </p><div class="informalexample"><pre class="programlisting">block in on ! fxp0 inet from 10.0.0.0/24 to any
block in inet from 10.0.0.1 to any
            </pre></div><p>
            Эти правила означают следующее:
          </p><div class="itemizedlist"><ul type="disc"><li>
              Блокируется весь входящий трафик из сети 10.0.0.1/24
              (поскольку на самом деле такой трафик может быть только
              исходящим).
            </li><li>
              Блокируется весь трафик с адреса 10.0.0.1. Машина не
              должна посылать пакеты сама себе, иначе как на кольцевом
              интерфейсе. Таким образом, весь входящий трафик у
              которого исходящий IP 10.0.0.1 должен рассматриваться
              как злонамеренный.
            </li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Замечание]" src="pf_02_files/note.png"></td><th align="left">Замечание</th></tr><tr><td valign="top" align="left"><p>
              Правило <code class="code">antispoof</code> может
              заблокировать работу кольцевого интерфейса. Как правило,
              на кольцевом интерфейсе трафик вообще не фильтруют:
            </p><div class="informalexample"><pre class="programlisting">set skip on lo0
antispoof for fxp0 inet
              </pre></div></td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Замечание]" src="pf_02_files/note.png"></td><th align="left">Замечание</th></tr><tr><td valign="top" align="left"><p>
              Использование правила <code class="code">antispoof</code> на интерфейсе, которому
              не присвоен IP-адрес превращается в правила типа:
            </p><div class="informalexample"><pre class="programlisting">block drop in on ! fxp0 inet all
block drop in inet all
              </pre></div><p>
              и может заблокировать <span class="emphasis"><em>весь</em></span> входящий
              трафик на <span class="emphasis"><em>всех</em></span> интерфейсах.
            </p></td></tr></tbody></table></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-rule-urpf"></a>C.2.1.4.11. Unicast Reverse Path Forwarding</h5></div></div></div><p>
            Начиная с <span class="acronym">OpenBSD</span>&nbsp;4.0 в пакетном
            фильтре появилась возможность проверять исходящие адреса
            при помощи таблицы маршрутизации. Если пакет подвергается
            проверке uRPF, исходящий IP адрес разыскивается в таблице
            маршрутизации, и если указанный в ней интерфейс
            соответствует интерфейсу, через который пришёл пакет, то
            пакет проходит проверку, а если нет&nbsp;&#8212; то мы
            имеем дело с IP-спуфингом.
          </p><p>
            Проверка uRPF осуществляется при помощи ключевого слова
            <code class="code">urpf-failed</code>:
          </p><div class="informalexample"><pre class="programlisting">block in quick from urpf-failed label uRPF
            </pre></div><p>
            Проверка uRPF работает только при симметричной
            маршрутизации. В противном случае трафик будет
            заблокирован.
          </p><p>
            Если машина является конечной точкой IPSec туннеля, нельзя
            включать проверку uRPF на интерфейсе enc0, иначе будет
            заблокирован весь инкапсулированный трафик. Рекомендуется
            пропускать все пакеты на интерфейсе enc0: <code class="code">set&nbsp;skip&nbsp;on&nbsp;enc0</code> или
            делать так:
          </p><div class="informalexample"><pre class="programlisting">block in quick on ! enc0 from urpf-failed label uRPF
            </pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Замечание]" src="pf_02_files/note.png"></td><th align="left">Замечание</th></tr><tr><td valign="top" align="left">
            В <span class="acronym">FreeBSD</span> uRPF пока не портирован.
          </td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Замечание]" src="pf_02_files/note.png"></td><th align="left">Замечание</th></tr><tr><td valign="top" align="left">
            В <span class="acronym">FreeBSD</span> интерфейс аналогичный
            упомянутому здесь интерфейсу <span class="acronym">OpenBSD</span>
            enc0 будет называться gif0.
          </td></tr></tbody></table></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-osfp"></a>C.2.1.4.12. Пассивное детектирование операционной системы</h5></div></div></div><p>
            Пакетный фильтр обладает возможностью определять из какой
            операционной системы был отправлен SYN пакет. Делается это
            на основе некоторых характерных особенностей работы TCP
            стека разных систем. Так, известно, что операционные
            системы <span class="acronym">Windows&nbsp;NT</span> склонны
            выставлять поле TTL в 128, тогда как
            <span class="acronym">Linux</span>,
            <span class="acronym">FreeBSD</span>&nbsp;&#8212; 64. Особенности
            работы стека приведены в файле
            <code class="filename">/etc/pf.os</code>. Это обычный текстовый файл,
            формат которого описан в нём же в комментариях. Текущий
            список fingerprint'ов можно увидеть при помощи команды
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> pfctl -s osfp
Class   Version Subtype(subversion)
-----   ------- -------------------
AIX
AIX     4.3
AIX     4.3     2
AIX     4.3     2-3
AIX     4.3     3
AIX     5.1
AIX     5.1-5.2
AIX     5.2
AIX     5.3
AIX     5.3     ML1
.......
            </pre></div><p>
            В моей системе насчитывается 330 fingerprint'ов. Включая
            <span class="acronym">Zaurus</span> (наладонник фирмы
            <span class="acronym">Sharp</span> с <span class="acronym">Linux</span>'ом)
            2-х версий.
          </p><p>
            Фильтрацию можно осуществлять при помощи ключевого слова
            <code class="code">os</code>:
          </p><div class="informalexample"><pre class="programlisting">pass  in on $ext_if from any os OpenBSD keep state
block in on $ext_if from any os "Windows 2000"
block in on $ext_if from any os "Linux 2.4 ts"
block in on $ext_if from any os unknown
            </pre></div><p>
            Ключевое слово <code class="code">unknown</code> означает
            пакет от системы чьи характеристики пакетному фильтру
            неизвестены.
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Замечание]" src="pf_02_files/note.png"></td><th align="left">Замечание</th></tr><tr><td valign="top" align="left"><div class="itemizedlist"><ul type="disc"><li>
                fingerprint операционной системы легко подделать.
              </li><li>
                При выходе патчей к операционной системе или при
                выходе новых релизов, поведение TCP стека может
                меняться.
              </li><li>
                Проверка OSFP работает только для TCP SYN пакетов. Она
                не работает с другими протоколами и с уже
                установленными соединениями.
              </li></ul></div></td></tr></tbody></table></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-rule-ip-opts"></a>C.2.1.4.13. Опции IP</h5></div></div></div><p>
            По умолчанию пакетный фильтр отбрасывает IP пакеты с
            выставленными опциями, для затруднения работы программ
            пытающихся узнать тип нашей операционной системы, например
            <span><strong class="command">nmap(1)</strong></span>. Если у вас есть приложения
            нуждающиеся в прохождении такого трафика, например
            multicast или IGMP, используйте опцию <code class="code">allow-opts</code>:
          </p><div class="informalexample"><pre class="programlisting">pass in quick on fxp0 all allow-opts
            </pre></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-rule-example"></a>C.2.1.4.14. Пример</h5></div></div></div><p>
            Ниже приведён краткий пример конфигурационного файла для
            брандмауэра между небольшой внутренней сетью и Интернетом.
            Здесь приведены только правила фильтрации, <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-nat" title="C.2.1.5. NAT">nat</a>, <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-rdr" title="C.2.1.6. Перенаправление пакетов, проброс портов">rdr</a>, <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-queue" title="C.2.2.4. Очереди, приоритеты (регулировка полосы пропускания)">queue</a> опущены.
          </p><div class="informalexample"><pre class="programlisting">ext_if  = "fxp0"
int_if  = "dc0"
lan_net = "192.168.0.0/24"

# Таблица содержит все IP адреса принадлежащие брандмауэру
table &lt;firewall&gt; const { self }

# Не фильтруем пакеты на кольцевом интерфейсе
set skip on lo0

# Нормализуем входящий трафик
scrub in all

# Политика по умолчанию
block all

# Включаем защиту от спуфинга на внутреннем интерфейсе
antispoof quick for $int_if inet

# Разрешаем ssh соединения из локальной сети только с доверенного
# компьютера 192.168.0.15. Использование "block return" приведёт  тому,
# что будет возвращаться пакет TCP RST для того, чтобы заблокированное
# соединение закрывалось правильным образом. "quick" используется для
# того, чтобы идущие ниже правила pass не переопределили данное
# действие.
block return in quick on $int_if proto tcp from ! 192.168.0.15 \
    to $int_if port ssh flags S/SA

# Разрешить весь трафик из локальной сети к брандмауэру и обратно
pass in  on $int_if from $lan_net to any
pass out on $int_if from any to $lan_net

# Пропустить исходящие tcp, udp и icmp пакеты на внешнем интерфейсе.
# Сохранять состояния соединений.
pass out on $ext_if proto tcp all modulate state flags S/SA
pass out on $ext_if proto { udp, icmp } all keep state

# Разрешить сединения ssh на внешнем интерфейсе если они направлены не
# брандмауэру, а другой машине (во внутренней сети). Первый пакет
# заносить в журнал, чтобы потом можно было сказать кто решил открыть
# соединение. Использовать syn proxy для защиты от syn флуда.
pass in log on $ext_if proto tcp from any to ! &lt;firewall&gt; \
    port ssh flags S/SA synproxy state
            </pre></div></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-nat"></a>C.2.1.5. NAT</h4></div></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-nat-theory"></a>C.2.1.5.1. Как работает NAT</h5></div></div></div><p>
            Суть трансляции адресов NAT описана в глоссарии: <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/go01.html#gloss-NAT">NAT</a>.
          </p><p>
            Когда клиент из внутренней сети пытается послать IP пакет
            в Интернет в этом пакете подменяется исходящий IP адрес на
            адрес шлюза, а так же, при необходимости, подменяется номер
            порта источника у пакетов TCP и UDP.  Делается запись в
            таблице состояний.
          </p><p>
            Обратные пакеты находятся в таблице состояний и с ними
            проделывается аналогичное обратное преобразование.
          </p><p>
            Ни внутренняя машина, ни внешняя не знают о существовании
            NAT. Всё происходит прозрачно. Для внутренней машины NAT
            это просто шлюз, а внешняя машина ничего не знает о
            внутренней и считает, что соединение открыто шлюзом.
            Обнаружить NAT можно только по косвенным признакам.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-nat+filter"></a>C.2.1.5.2. NAT и фильтрация</h5></div></div></div><p>
            Пакеты подвергаемые трансляции проходят через фильтр и
            будут отброшены или пропущены в зависимости от правил
            которые там встретятся. Единственное
            исключение&nbsp;&#8212; если в правиле NAT встретится
            ключевое слово <code class="code">pass</code>, то в этом
            случае пакет не будет подвергнут фильтрации.
          </p><p>
            Трансляция осуществляется до фильтрации. Правила фильтра
            увидят уже оттранслированные пакеты.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-forward"></a>C.2.1.5.3. IP forward, проброс пакетов</h5></div></div></div><p>
            Поскольку NAT всегда используется на шлюзах и
            маршрутизаторах, необходимо включить проброс пакетов. Для
            этого надо выставить переменную ядра <code class="code">net.inet.ip.forwarding</code> в истину.
            Для этого во всех системах <span class="acronym">BSD</span>
            используется программа <span><strong class="command">sysctl(8)</strong></span>
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> sysctl -w net.inet.ip.forwarding=1
<code class="prompt">#</code> sysctl -w net.inet6.ip6.forwarding=1   &lt;==(если исппользуется IPv6)
            </pre></div><p>
            Чтобы сделать эти изменения постоянными следует
            добавить в файл <code class="filename">/etc/sysctl.conf</code>
            такие строки:
          </p><div class="informalexample"><pre class="programlisting">net.inet.ip.forwarding=1
net.inet6.ip6.forwarding=1
            </pre></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-nat-config"></a>C.2.1.5.4. Конфигурирование NAT</h5></div></div></div><p>
            Синтаксическая диаграмма правила NAT в
            <code class="filename">pf.conf(5)</code> выглядит следующим
            образом:
          </p><div class="informalexample"><pre class="programlisting">nat [pass [log]] on interface [af] from src_addr [port src_port] to \
    dst_addr [port dst_port] -&gt; ext_addr [pool_type] [static-port]
            </pre></div><div class="variablelist"><dl><dt><span class="term"><code class="code">nat</code></span></dt><dd>
                Ключевое слово с которого начинаются правила NAT.
              </dd><dt><span class="term"><code class="code">pass</code></span></dt><dd>
                Указывает, что пакет не должен направляться на
                фильтрующие правила.
              </dd><dt><span class="term"><code class="code">log</code></span></dt><dd>
                Если указано ключевое слово <code class="code">pass</code>, пакеты заносятся в журнал
                при помощи <span><strong class="command">pflogd(8)</strong></span>. В норме в
                журнал попадает только первый пакет, при необходимости
                журналировать все пакеты используйте <code class="code">log (all)</code>.
              </dd><dt><span class="term"><code class="code">interface</code></span></dt><dd>
                  Имя сетевого интерфейса (или имя группы сетевых
                  интерфейсов) на котором осуществляется трансляция.
                </dd><dt><span class="term"><code class="code">af</code></span></dt><dd>
                Address family&nbsp;&#8212; <code class="code">inet</code> для адресов IPv4 и <code class="code">inet6</code> для адресов IPv6. Обычно
                пакетный фильтр может определить требуемый протокол по
                указанным в правиле адресам.
              </dd><dt><span class="term"><code class="code">src_addr</code>, <code class="code">dst_addr</code></span></dt><dd><p>
                  Адрес источника или назначения пакета. Возможные
                  варианты:
                </p><div class="itemizedlist"><ul type="disc"><li>
                    Просто одиночный адрес IPv4, или IPv6
                  </li><li>
                    Сеть в формате CIDR
                  </li><li>
                    Полностью разрешённое доменное имя (FQDN), которое
                    будет разрешено через DNS при загрузке правила. Все
                    адреса соответствующие данному имени будут помещены
                    в данное правило.
                  </li><li>
                    Имя интерфейса или группы. Все адреса закреплённые
                    за интерфейсом будут подставлены в правило.
                  </li><li>
                    Имя интерфейса, за которым идёт <code class="code">/netmask</code> (например <code class="code">/24</code>). Ко всем адресам
                    закреплённым за данным интерфейсом, будет
                    добавлена данная сетевая маска, и полученные сети
                    CIDR будут добавлены в данное правило.
                  </li><li>
                    Имя сетевого интерфейса или группы, взятое в
                    круглые скобки <code class="code">(...)</code>.
                    Данное правило будет автоматически меняться при
                    смене адреса закреплённого за интерфейсом.  Это
                    может быть полезно, например, для DHCP клиентов.
                  </li><li><p>
                      Имя сетевого интерфейса, за которым идёт один из
                      следующих модификаторов:
                    </p><div class="variablelist"><dl><dt><span class="term"><code class="code">:network</code></span></dt><dd>
                          Замещается сетью CIDR закреплённой за данным
                          интерфейсом
                        </dd><dt><span class="term"><code class="code">:broadcast</code></span></dt><dd>
                          Замещается широковещательным адресом
                          закреплённым за данным интерфейсом
                        </dd><dt><span class="term"><code class="code">:peer</code></span></dt><dd>
                          Замещается адресом партнёра для
                          point-to-point интерфейса.
                        </dd></dl></div><p>
                      Кроме того, за именем интерфейса или за любым из
                      перечисленных выше модификаторов, может
                      следовать модификатор <code class="code">:0</code>, указывающий на то,
                      что нас не интересуют алиасы, т.е.
                      дополнительные адреса, котрые можно добавить к
                      сетевому интерфейсу (см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/ch06s15.html" title="6.15. Знание как и когда устанавливать или удалять алиасы сетевого интерфейса">Раздел&nbsp;6.15, &#171;Знание как и когда устанавливать или удалять алиасы сетевого интерфейса&#187;</a>).  Например: <code class="code">fxp0:network:0</code>.
                    </p></li><li><a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-tables" title="C.2.1.3. Таблицы">Таблица</a></li><li>
                    Любая из приведённых выше конструкций с символом
                    отрицания&nbsp;&#8212; <code class="code">!</code>.
                  </li><li>
                    Перечень конструкций с использованием <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-lists" title="C.2.1.1. Списки">списка</a>.
                  </li><li>
                    Ключевое слово <code class="code">any</code>,
                    означающее все адреса.
                  </li><li>
                    Ключевое слово <code class="code">all</code>,
                    которое является эквивалентом конструкции <code class="code">from any to any</code>.
                  </li></ul></div></dd><dt><span class="term"><code class="code">src_port</code>, <code class="code">dst_port</code></span></dt><dd><p>
                  </p><p>
                    Порт источника или назначения в заголовке
                    транспортного уровня. Возможны следующие варианты:
                  </p><p>
                  </p><div class="itemizedlist"><ul type="disc"><li>
                      Число от 1 до 65535
                    </li><li>
                      Имя протокола из файла
                      <code class="filename">/etc/services</code>.
                    </li><li>
                      Перечень конструкций с использованием <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-lists" title="C.2.1.1. Списки">списка</a>.
                    </li><li><p>
                        Диапазоны портов с применением следующих
                        операторов:
                      </p><div class="variablelist"><dl><dt><span class="term"><code class="code">!=</code></span></dt><dd>
                            Неравно
                          </dd><dt><span class="term"><code class="code">&lt;</code></span></dt><dd>
                            Меньше чем
                          </dd><dt><span class="term"><code class="code">&gt;</code></span></dt><dd>
                            Больше чем
                          </dd><dt><span class="term"><code class="code">&lt;=</code></span></dt><dd>
                            Меньше или равно
                          </dd><dt><span class="term"><code class="code">&gt;=</code></span></dt><dd>
                            Больше или равно
                          </dd><dt><span class="term"><code class="code">&gt;&lt;</code></span></dt><dd>
                            Диапазон (исключающий концы)
                          </dd><dt><span class="term"><code class="code">&lt;&gt;</code></span></dt><dd>
                            Инвертированный диапазон
                          </dd><dt><span class="term"><code class="code">:</code></span></dt><dd>
                            Диапазон включающий концы
                          </dd></dl></div><p>
                        Последние три оператора бинарные (принимают
                        два аргумента). При этом <code class="code">&lt;&gt;</code> и <code class="code">&gt;&lt;</code> не включают
                        аргументы в диапазон, а <code class="code">:</code> включает.
                      </p></li></ul></div><p>
                </p></dd><dt><span class="term"><code class="code">ext_addr</code></span></dt><dd>
                Внешний адрес NAT шлюза, к которому приводится адрес
                источника при трансляции. Допустимы те же варианты,
                что и для <code class="code">src_addr</code> и <code class="code">dst_addr</code>, кроме таблиц,
                отрицаний с помощью <code class="code">!</code> и
                ключевого слова <code class="code">any</code>. Нельзя
                использовать модификатор <code class="code">:broadcast</code>.
              </dd><dt><span class="term"><code class="code">pool_type</code></span></dt><dd>
                Укаывает тип адресного пула (см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pools" title="C.2.2.5. Адресные пулы, балансировка нагрузки">Раздел&nbsp;C.2.2.5, &#171;Адресные пулы, балансировка нагрузки&#187;</a>).
              </dd><dt><span class="term"><code class="code">static-port</code></span></dt><dd>
                Указывает фильтру не транслировать номера портов
                источника.
              </dd></dl></div><p>
            В большинстве случаев для NAT трансляции годится примерно
            такая строка:
          </p><div class="informalexample"><pre class="programlisting">nat on tl0 from 192.168.1.0/24 to any -&gt; 24.5.0.5
            </pre></div><p>
            Это правило указывает, что надо осуществить NAT трансляцию
            на интерфейсе tl0 для каждого пакета пришедшего из сети
            192.168.1.0/24 подменив адрес источника на 24.5.0.5.
          </p><p>
            Предыдущая строка корректна, но рекомендуется для
            облегчения поддержки брандмауэра использовать другую форму
            записи (в примере dc0 внутренний интерфейс, а tl0
            внешний):
          </p><div class="informalexample"><pre class="programlisting">nat on tl0 from dc0:network to any -&gt; tl0
            </pre></div><p>
            При использовании имени интерфейса, как указано выше,
            адрес будет определён и подставлен когда
            <code class="filename">pf.conf</code> загружается, но не на лету.
            Это может вызвать проблемы, если адрес интерфейсу
            присваивается по DHCP и меняется во время работы.  Чтобы
            избежать этой проблемы надо указывать адрес интерфейса в
            круглых скобках.
          </p><div class="informalexample"><pre class="programlisting">nat on tl0 from dc0:network to any -&gt; (tl0)
            </pre></div><p>
            Трансляция работает как для IPv4 так и для IPv6.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-binat"></a>C.2.1.5.5. Bidirectional mapping (соответствие 1:1)</h5></div></div></div><p>
            Соответствия между двумя хостами 1:1 можно достичь при
            помощи правила <code class="code">binat</code>. Это
            правило ставит в соответствие один IP адрес другому. Это
            можно использовать, например, для того, чтобы предоставить
            доступ к web-серверу во внутренней сети по внешнему
            IP-адресу. Соединения из Интернета к внешнему адресу шлюза
            будут перенаправлены на внутренний web-сервер, а
            соединения от сервера (например DNS запросы) будут
            превращены в запросы шлюза. <code class="code">binat</code> никогда не меняет номера
            портов TCP и UDP.
          </p><p>
            Пример:
          </p><div class="informalexample"><pre class="programlisting">web_serv_int = "192.168.1.100"
web_serv_ext = "24.5.0.6"
binat on tl0 from $web_serv_int to any -&gt; $web_serv_ext
            </pre></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-nonat"></a>C.2.1.5.6. Исключения из трансляции</h5></div></div></div><p>
            Можно сделать исключения из трансляции при помощи
            ключевого слова <code class="code">no</code>. Например,
            правила NAT трансляции из примера выше можно изменить
            следующим образом:
          </p><div class="informalexample"><pre class="programlisting">no nat on tl0 from 192.168.1.208 to any
nat on tl0 from 192.168.1.0/24 to any -&gt; 24.2.74.79
            </pre></div><p>
            Вся сеть 192.168.1.0/24 будет транслироваться к адресу
            24.2.74.79, кроме пакетов идущих от хоста 192.168.1.208.
          </p><p>
            Здесь <span class="emphasis"><em>первое правило выигрывает</em></span>. Если
            есть ключевое слово <code class="code">no</code>
            трансляция не производится. Ключевое слово <code class="code">no</code> можно употреблять с правилами
            <code class="code">binat</code> и <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-rdr" title="C.2.1.6. Перенаправление пакетов, проброс портов"><code class="code">rdr</code></a>.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-nat-state"></a>C.2.1.5.7. Проверка состояния правил NAT</h5></div></div></div><p>
            Чтобы увидеть состояния соединений подвергаемых NAT
            трансляции можно воспользоваться командой
            <span><strong class="command">pfctl(8)</strong></span> с аргументом
            <code class="option">-s&nbsp;state</code>.
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> pfctl -s state
fxp0 TCP 192.168.1.35:2132 -&gt; 24.5.0.5:53136 -&gt; 65.42.33.245:22 TIME_WAIT:TIME_WAIT
fxp0 UDP 192.168.1.35:2491 -&gt; 24.5.0.5:60527 -&gt; 24.2.68.33:53   MULTIPLE:SINGLE
            </pre></div><p>
            Этот отчёт (первая срока) означает следующее:
          </p><div class="variablelist"><dl><dt><span class="term">fxp0</span></dt><dd>
                Интерфейс на котором происходит трансляция.
              </dd><dt><span class="term">TCP</span></dt><dd>
                Протокол
              </dd><dt><span class="term">192.168.1.35:2132</span></dt><dd>
                IP адрес внутренней машины (192.168.1.35) и порт
                открытый на этой машине (2132). Эти параметры
                подменяются при трансляции.
              </dd><dt><span class="term">24.5.0.5:53136</span></dt><dd>
                Внешний IP адрес шлюза (24.5.0.5) и порт открытый на
                шлюзе (53136). Эти параметры подставляются при
                трансляции на место исходного адреса и исходного
                порта.
              </dd><dt><span class="term">65.42.33.245:22</span></dt><dd>
                IP адрес назначения (65.42.33.245) и порт назначения
                (22).
              </dd><dt><span class="term">TIME_WAIT:TIME_WAIT</span></dt><dd>
                Пакетный фильтр считает, что TCP соединение пребывает
                в указанном состоянии.
              </dd></dl></div></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-rdr"></a>C.2.1.6. Перенаправление пакетов, проброс портов</h4></div></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-rdr-intro"></a>C.2.1.6.1. Введение</h5></div></div></div><p>
            Если у вас работает NAT, вам доступен весь Интернет, но как
            быть если за шлюзом с NAT, в приватной сети находится машина
            доступ к которой нужен снаружи? Здесь нам поможет проброс
            портов. С его помощью мы можем перенаправлять входящий
            трафик на машину расположенную за шлюзом с NAT.
          </p><p>
            Пример:
          </p><div class="informalexample"><pre class="programlisting">rdr on tl0 proto tcp from any to any port 80 -&gt; 192.168.1.20
            </pre></div><p>
            С помощью этого правила все обращения к 80 порту будут
            пробрасываться на машину 192.168.1.20. (В
            <span class="acronym">Linux</span> <span><strong class="command">netfilter</strong></span> это
            действие называется <span class="acronym">DNAT</span>, так как у
            пакета подменяется не source IP, а destination IP.)
          </p><p>
            Директива <code class="code">from any to any</code>
            полезна, но если вы знаете из какий сетей будут приходить
            запросы, вы можете сузить правило:
          </p><div class="informalexample"><pre class="programlisting">rdr on tl0 proto tcp from 27.146.49.0/24 to any port 80 -&gt; \
   192.168.1.20
            </pre></div><p>
            Таким образом, можно пробросить только некоторую подсеть.
            Данный подход позволяет так же пробрасывать разные подсети на
            разные хосты. Мы можем использовать это свойство для того,
            чтобы давать пользователям доступ к их компьютерам в
            локальной сети на основании адреса с которого они обращаются
            к шлюзу:
          </p><div class="informalexample"><pre class="programlisting">rdr on tl0 proto tcp from 27.146.49.14 to any port 80 -&gt; \
   192.168.1.20
rdr on tl0 proto tcp from 16.114.4.89 to any port 80 -&gt; \
   192.168.1.22
rdr on tl0 proto tcp from 24.2.74.178 to any port 80 -&gt; \
   192.168.1.23
            </pre></div><p>
            Так же можно пробрасывать диапазоны портов:
          </p><div class="informalexample"><pre class="programlisting">rdr on tl0 proto tcp from any to any port 5000:5500 -&gt; \
   192.168.1.20 <a name="pf-rdr-ex1-area" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-rdr-ex1-co"><img src="pf_02_files/1.png" alt="1" border="0"></a>
rdr on tl0 proto tcp from any to any port 5000:5500 -&gt; \
   192.168.1.20 port 6000 <a name="pf-rdr-ex2-area" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-rdr-ex2-co"><img src="pf_02_files/2.png" alt="2" border="0"></a>
rdr on tl0 proto tcp from any to any port 5000:5500 -&gt; \
   192.168.1.20 port 7000:* <a name="pf-rdr-ex3-area" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-rdr-ex3-co"><img src="pf_02_files/3.png" alt="3" border="0"></a>
            </pre></div><div class="calloutlist"><table summary="Callout list" border="0"><tbody><tr><td valign="top" width="5%" align="left"><a name="pf-rdr-ex1-co"></a><a href="#pf-rdr-ex1-area"><img src="pf_02_files/1.png" alt="1" border="0"></a> </td><td valign="top" align="left">
                Запросы пришедшие на порты с 5000 по 5500 включительно
                перенаправлены на хост 192.168.1.20 один к одному т.е.
                5000 на 5000, 5001 на 5001 и&nbsp;т.д.
              </td></tr><tr><td valign="top" width="5%" align="left"><a name="pf-rdr-ex2-co"></a><a href="#pf-rdr-ex2-area"><img src="pf_02_files/2.png" alt="2" border="0"></a> </td><td valign="top" align="left">
                Запросы пришедшие на порты с 5000 по 5500 включительно
                перенаправлены на хост 192.168.1.20, причём все на порт
                6000.
              </td></tr><tr><td valign="top" width="5%" align="left"><a name="pf-rdr-ex3-co"></a><a href="#pf-rdr-ex3-area"><img src="pf_02_files/3.png" alt="3" border="0"></a> </td><td valign="top" align="left">
                Запросы пришедшие на порты с 5000 по 5500 включительно
                перенаправлены на хост 192.168.1.20 со сдвигом номера
                порта, т.е. 5000 на 7000, 5001 на 7001 и&nbsp;т.д.
              </td></tr></tbody></table></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-rdr+filter"></a>C.2.1.6.2. Перенаправление и фильтрация пакетов</h5></div></div></div><p>
            Транслированные пакеты, как и в случае с NAT, направляются
            на правила фильтра и могут быть как приняты, так и
            отброшены.
          </p><p>
            Единственное исключение: если в правиле <code class="code">rdr</code> присутствует ключевое слово <code class="code">pass</code>. В этом случае пакет не
            направляется в фильтр. Вы можете считать, что это такой
            короткий способ записать два правила, в одном из которых
            осуществляется трансляция, а в другом употребляется ключевое
            слово <code class="code">pass</code> с <code class="code">keep state</code>. Однако, если вы хотите
            использовать какие-то другие возможности пакетного фильтра,
            например <code class="code">modulate state</code> или <code class="code">synproxy state</code>, вам придётся
            расписывать это подробно, т.е. <code class="code">rdr
              pass</code> в этом случае не подходит.
          </p><p>
            Кроме того, имейте в виду, что на фильтр пакеты посылаются
            <span class="emphasis"><em>после</em></span> трансляции.
          </p><p>
            Рассмотрим следующий сценарий:
          </p><div class="itemizedlist"><ul type="disc"><li>
              192.0.2.1&nbsp;&#8212; хост в Интернет
            </li><li>
              24.65.1.13&nbsp;&#8212; внешний адрес
              <span class="acronym">OpenBSD</span> (или
              <span class="acronym">FreeBSD</span>) шлюза
            </li><li>
              192.168.1.5&nbsp;&#8212; внутренний IP адрес web-сервера.
            </li></ul></div><p>
            Правило перенаправления:
          </p><div class="informalexample"><pre class="programlisting">rdr on tl0 proto tcp from 192.0.2.1 to 24.65.1.13 port 80 \
   -&gt; 192.168.1.5 port 8000
            </pre></div><p>
            Вид пакета перед трансляцией:
          </p><div class="itemizedlist"><ul type="disc"><li>
              Исходящий адрес&nbsp;&#8212; 192.0.2.1
            </li><li>
              Исходящий порт&nbsp;&#8212; 4028
            </li><li>
              Адрес назначения&nbsp;&#8212; 24.65.1.13
            </li><li>
              Порт назначения&nbsp;&#8212; 80
            </li></ul></div><p>
            Вид пакета после трансляции:
          </p><div class="itemizedlist"><ul type="disc"><li>
              Исходящий адрес&nbsp;&#8212; 192.0.2.1
            </li><li>
              Исходящий порт&nbsp;&#8212; 4028
            </li><li>
              Адрес назначения&nbsp;&#8212; 192.168.1.5
            </li><li>
              Порт назначения&nbsp;&#8212; 8000
            </li></ul></div><p>
            Правила фильтра увидят что пакет идёт на машину 192.168.1.5
            на порт 8000
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-rdr-security"></a>C.2.1.6.3. Вопросы безопасности</h5></div></div></div><p>
            Создание подобных отверстий в брандмауэре связано с
            уменьшением безопасности системы. Например, если у вас во
            внутренней сети находится web-сервер и вы пропустили на него
            трафик из Интернет, то злоумышленник может используя
            уязвимости в работе web-сервера или CGI сценария, получить
            доступ к web-серверу и, таким образом, проникнет в
            защищённую вами локальную сеть.
          </p><p>
            Снизить риск возникновения подобной ситуации можно путём
            построения демилитаризованной зоны DMZ (см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/go01.html#gloss-DMZ">DMZ</a>).
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-rdr-reflection"></a>C.2.1.6.4. Перенаправление и отражение</h5></div></div></div><p>
            Перенаправление часто используется для предоставления
            доступа внешним машинам к внутреннему серверу:
          </p><div class="informalexample"><pre class="programlisting">server = 192.168.1.40
rdr on $ext_if proto tcp from any to $ext_if port 80 -&gt; $server \
   port 80
            </pre></div><p>
            Однако при тестировании правил перенаправления из внутренней
            сети они не работают. Дело в том, что пакеты из внутренней
            сети не проходят через внешний интерфейс шлюза (<code class="code">$ext_if</code> в примере) и потому не
            подвергаются трансляции.
          </p><p>
            Добавление второго <code class="code">rdr</code> правила не
            спасает ситуацию: пакет проходит через внутренний интерфейс,
            ему заменяют адрес назначения и он направляется на сервер,
            однако исходящий адрес при этом не исправляется и поэтому
            сервер будет овечать непосредственно клиенту минуя шлюз.
            Клиент при этом ждёт ответа от шлюза, а не от сервера. Таким
            образом, соединение так и не будет установлено.
          </p><p>
            И всё таки желательно из внутренней сети видеть сервер так
            же как он виден из внешней и так, чтобы для клиента всё было
            прозрачно. Существует несколько способов решения этой
            проблемы.
          </p><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-pf.conf-rdr-DNS"></a>C.2.1.6.4.1. Создание локального DNS</h6></div></div></div><p>
              Сервер DNS можно настроить так, что он будет давать разные
              ответы в разные сети. Можно сделать так, чтобы локальные
              клиенты ходили на сервер непосредственно, без помощи
              шлюза. Такое решение, к тому же, снижает нагрузку на шлюз.
            </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-pf.conf-rdr-DMZ"></a>C.2.1.6.4.2. Перемещение сервера в отдельную сеть</h6></div></div></div><p>
              Можно переместить сервер в отдельную сеть (см. так же <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/go01.html#gloss-DMZ">DMZ</a>) и добавить новый сетевой интерфейс
              в шлюз.
            </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-rdr-tcpproxy"></a>C.2.1.6.4.3. TCP proxy</h6></div></div></div><p>
              Можно произвести проксирование TCP соединений при помощи
              приложений из userspace. Приложение перехватывает
              соединение, устанавливает соединение с сервером и далее
              пробрасывает данные через себя. Простейший пример можно
              сделать при помощи <span><strong class="command">inetd(8)</strong></span> (см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/ch05s17.html#3.5.17-inetd" title="5.17.2. Суперсервер inetd(8)">Раздел&nbsp;5.17.2, &#171;Суперсервер <span><strong class="command">inetd(8)</strong></span>&#187;</a>)и <span><strong class="command">nc(1)</strong></span> (см.
              <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/ch06s04.html#3.6.4-telnet" title="6.4.4. telnet(1), nc(1)">Раздел&nbsp;6.4.4, &#171;<span><strong class="command">telnet(1)</strong></span>, <span><strong class="command">nc(1)</strong></span>&#187;</a>). Следующая строка в
              <code class="filename">/etc/inetd.conf(5)</code> создаёт сокет
              привязанный к кольцевому интерфейсу, порт номер 5000.
              Соединение пробрасывается на 80-й порт машины
              192.168.1.10:
            </p><div class="informalexample"><pre class="programlisting">127.0.0.1:5000 stream tcp nowait nobody /usr/bin/nc nc -w 20 192.168.1.10 80
              </pre></div><p>
              Теперь на внутреннем интерфейсе мы можем связать 80-й порт
              с нашим proxy-сервером:
            </p><div class="informalexample"><pre class="programlisting">rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; \
   127.0.0.1 port 5000
              </pre></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-pf.conf-rdr+nat"></a>C.2.1.6.4.4. RDR в комбинации с NAT</h6></div></div></div><p>
              И наконец, в комбинации с правилом NAT можно достичь того,
              что трансляция адресов источника так же будет
              осуществляться и соединение будет устанавливаться
              ожидаемым образом.
            </p><div class="informalexample"><pre class="programlisting">rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; $server 
no nat on $int_if proto tcp from $int_if to $int_net
nat on $int_if proto tcp from $int_net to $server port 80 -&gt; $int_if
              </pre></div><p>
              Эти правила приведут к тому, что первый пакет поступивший
              от клиента будет  заново транслирован, когда будет
              отправлен через внутренний интерфейс, при этом у него
              будет подменён адрес источника на внутренний адрес шлюза.
              Внутренний сервер ответит шлюзу, который вернёт адреса
              обратно благодаря NAT и RDR трансляциям и пакет отправится
              к клиенту. Это достаточно сложный приём. Нужна
              осторожность, чтобы не применить правила NAT к другому
              трафику, например к внешним соединениям (прошедшим через
              другие правила <code class="code">rdr</code>) или к
              соединениям самого шлюза. Так же имейте ввиду, что это
              преобразование приводит к тому, что TCP/IP стек видит
              данные пакеты, полученные внутренним интерфейсом, как
              направляющиеся внутрь сети.
            </p><p>
              Авторы документации к пакетному фильтру рекомендуют в
              общем случае использовать какое-нибудь из предыдущих
              решений вместо последнего.
            </p></div></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-pf.conf-hacks"></a>C.2.1.7. Приёмы используемые для упрощения файла <code class="filename">pf.conf(5)</code></h4></div></div></div><p>
          Пакетный фильтр предоставляет различные способы упрощения
          конфигурационного файла. Хорошим примером является
          использование <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-lists" title="C.2.1.1. Списки">списков и
            макросов</a>. Вдобавок язык и грамматика
          <code class="filename">pf.conf(5)</code> весьма гибки и позволяют в
          ряде случаев опускать ключевые слова и употреблять их в разном
          порядке, таким образом администратор не обязан зубрить
          синтаксис файла <code class="filename">pf.conf(5)</code>. В целом можно
          сказать, что чем проще правила, тем проще осуществлять
          поддержку брандмауэра.
        </p><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-hacks-macros"></a>C.2.1.7.1. Использование Макросов</h5></div></div></div><p>
            Макросы полезны так как позволяют использовать понятные
            имена вместо имён интерфейсов и адресов. Если меняется IP
            адрес сервера можно просто переопределить макрос вместо
            того, чтобы переписывать весь файл. Аналогичные соображения
            касаются имён интерфейсов. Макросы позволяют упростить
            модифицирование <code class="filename">pf.conf(5)</code> в случае
            замены сетевой карты или при необходимости переноса одного и
            того же файла с одной машины на другую.
          </p><p>
            Пример:
          </p><div class="informalexample"><pre class="programlisting"># define macros for each network interface
IntIF = "dc0"
ExtIF = "fxp0"
DmzIF = "fxp1" 

# define our networks
IntNet = "192.168.0.0/24"
ExtAdd = "24.65.13.4"
DmzNet = "10.0.0.0/24"
            </pre></div><p>
            Если в LAN появятся новые сети, или сети будут
            перенумерованы, достаточно будет поменять одну строку:
          </p><div class="informalexample"><pre class="programlisting">IntNet = "{ 192.168.0.0/24, 192.168.1.0/24 }"
            </pre></div><p>
            Теперь после перезагрузки правил всё будет работать
            по-прежнему.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-hacks-lists"></a>C.2.1.7.2. Использование списков</h5></div></div></div><p>
            Следующие 8&nbsp;строк служат для того, чтобы блокировать
            трафик связанный с приватными сетями, описаными в [<a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/bi01.html#RFC-1918" title="[RFC-1918]">RFC-1918</a>], Нахождение таких пакетов в
            глобальной сети может вызвать проблемы.
          </p><div class="informalexample"><pre class="programlisting">block in  quick on tl0 inet from 127.0.0.0/8 to any
block in  quick on tl0 inet from 192.168.0.0/16 to any
block in  quick on tl0 inet from 172.16.0.0/12 to any
block in  quick on tl0 inet from 10.0.0.0/8 to any
block out quick on tl0 inet from any to 127.0.0.0/8
block out quick on tl0 inet from any to 192.168.0.0/16
block out quick on tl0 inet from any to 172.16.0.0/12
block out quick on tl0 inet from any to 10.0.0.0/8
            </pre></div><p>
            Упростим эти правила при помощи списков:
          </p><div class="informalexample"><pre class="programlisting">block in  quick on tl0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
   172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on tl0 inet from any to { 127.0.0.0/8, \
   192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }
            </pre></div><p>
            Ещё лучше, если мы сделаем это с использованием макросов:
          </p><div class="informalexample"><pre class="programlisting">NoRouteIPs = "{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, \
   10.0.0.0/8 }" 
ExtIF = "tl0"
block in  quick on $ExtIF from $NoRouteIPs to any
block out quick on $ExtIF from any to $NoRouteIPs
            </pre></div><p>
            Заметьте, что макросы и списки упрощают файл
            <code class="filename">pf.conf</code>, однако предыдущие строки всё
            равно раскрываются в те же 8&nbsp;правил.
          </p><p>
            Макросы можно использовать не только для хранения адресов,
            интерфейсов и портов, но вообще везде:
          </p><div class="informalexample"><pre class="programlisting">pre = "pass in quick on ep0 inet proto tcp from "
post = "to any port { 80, 6667 } keep state"

# David's classroom
$pre 21.14.24.80 $post

# Nick's home
$pre 24.2.74.79 $post
$pre 24.2.74.178 $post
            </pre></div><p>
            Эти правила раскрываются в следующие:
          </p><div class="informalexample"><pre class="programlisting">pass in quick on ep0 inet proto tcp from 21.14.24.80 to any \
   port = 80 keep state
pass in quick on ep0 inet proto tcp from 21.14.24.80 to any \
   port = 6667 keep state
pass in quick on ep0 inet proto tcp from 24.2.74.79 to any \
   port = 80 keep state
pass in quick on ep0 inet proto tcp from 24.2.74.79 to any \
   port = 6667 keep state
pass in quick on ep0 inet proto tcp from 24.2.74.178 to any \
   port = 80 keep state
pass in quick on ep0 inet proto tcp from 24.2.74.178 to any \
   port = 6667 keep state
            </pre></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pf.conf-hacks-grammar"></a>C.2.1.7.3. Грамматика пакетного фильтра</h5></div></div></div><p>
            Пакетный фильтр обладает гибкой в тоже время человечной
            грамматикой. Нет необходимости строго помнить порядок
            ключевых слов и строго придерживаться какого-то
            определённого стиля.
          </p><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-pf.conf-hacks-grammar-nokw"></a>C.2.1.7.3.1. Можно опускать ключевые слова</h6></div></div></div><p>
              Для определения политики отбрасывающей по умолчанию
              пакеты, следует задать два правила:
            </p><div class="informalexample"><pre class="programlisting">block in  all
block out all
              </pre></div><p>
              Это можно сократить до
            </p><div class="informalexample"><pre class="programlisting">block all
              </pre></div><p>
              Когда направление не указано, пакетный фильтр считает, что
              пакеты следуют в обе стороны.
            </p><p>
              Аналогично можно не писать <code class="code">from any to
                any</code> и <code class="code">all</code>, например:
            </p><div class="informalexample"><pre class="programlisting">block in on rl0 all
pass  in quick log on rl0 proto tcp from any to any port 22 keep state
              </pre></div><p>
              Можно упростить до
            </p><div class="informalexample"><pre class="programlisting">block in on rl0
pass  in quick log on rl0 proto tcp to port 22 keep state
              </pre></div><p>
              Первое правило блокирует все пакеты входящие через
              интерфейс rl0. Второе пропускает входящие пакеты, если они
              идут на 22-й порт.
            </p><p>
              Правила блокирующие пакеты и отсылающие пакеты TCP RST и
              ICMP Unreachable должны выглядеть так:
            </p><div class="informalexample"><pre class="programlisting">block in all
block return-rst in proto tcp all
block return-icmp in proto udp all
block out all
block return-rst out proto tcp all
block return-icmp out proto udp all
              </pre></div><p>
              Их можно упростить до одной строки:
            </p><div class="informalexample"><pre class="programlisting">block return
              </pre></div><p>
              Когда пакетный фильтр видит ключевое слово<code class="code">return</code>, он сам догадывается на
              какой протокол каким пакетом следует отвечать, а на какие
              протоколы вообще не следует посылать никакого ответа при
              блокировании соединений.
            </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-pf.conf-hacks-grammar-kworder"></a>C.2.1.7.3.2. Порядок следования ключевых слов</h6></div></div></div><p>
              Порядок следования ключевых слов в большинстве случаев
              гибок. Например, следующее правило:
            </p><div class="informalexample"><pre class="programlisting">pass in log quick on rl0 proto tcp to port 22 \
   flags S/SA keep state queue ssh label ssh
              </pre></div><p>
              Можно переписать так:
            </p><div class="informalexample"><pre class="programlisting">pass in quick log on rl0 proto tcp to port 22 \
   queue ssh keep state label ssh flags S/SA
              </pre></div><p>
              Другие похожие варианты тоже будут работать.
            </p></div></div></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h3 class="title"><a name="pf-pf.conf-advansed"></a>C.2.2. Углублённое конфигурирование Пакетного фильтра</h3></div></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-options"></a>C.2.2.1. Опции в пакетном фильтре</h4></div></div></div><p>
          Опции в <code class="filename">pf.conf(5)</code> устанавливаются при
          помощи директивы <code class="code">set</code>.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Замечание]" src="pf_02_files/note.png"></td><th align="left">Замечание</th></tr><tr><td valign="top" align="left">
          Начиная с <span class="acronym">OpenBSD</span>&nbsp;3.7 сменилось
          поведение пакетного фильтра относительно опций: раньше, если
          опция устанавливалась, она уже никогда не принимала своего
          значения по умолчанию. Теперь, опция принимает значение по
          умолчанию, если её удаляют из правил, а затем перезагружают
          правила.
        </td></tr></tbody></table></div><p>
          Пример задания опций в пакетном фильтре:
        </p><div class="informalexample"><pre class="programlisting">set timeout interval 10
set timeout frag 30
set limit { frags 5000, states 2500 }
set optimization high-latency
set block-policy return
set loginterface dc0
set fingerprints "/etc/pf.os.test"
set skip on lo0
set state-policy if-bound
          </pre></div><div class="variablelist"><dl><dt><span class="term"><code class="option">set block-policy</code> option</span></dt><dd><p>
                Установить поведение по умолчанию для <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-filter" title="C.2.1.4. Фильтрация пакетов">правил фильтра</a>,
                когда срабатывает правило <span><strong class="command">block</strong></span>.
                Возможные варианты:
              </p><div class="itemizedlist"><ul type="disc"><li><code class="option">drop</code>&nbsp;&#8212; пакет
                  молча отбрасывается;
                </li><li><code class="option">return</code>&nbsp;&#8212; для
                  отброшенных пакетов TCP отсылается пакет TCP RST, для
                  прочих ICMP Unreachable.
                </li></ul></div><p>
                В конкретных правилах значение опции может быть
                переопределено. Умолчание&nbsp;&#8212;
                <code class="option">drop</code>
              </p></dd><dt><span class="term"><code class="option">set debug</code> option</span></dt><dd><p>
                Установить уровень отладки для пакетного фильтра:
              </p><div class="itemizedlist"><ul type="disc"><li><code class="option">none</code>&nbsp;&#8212; не
                  показывать отладочных сообщений;
                </li><li><code class="option">urgent</code>&nbsp;&#8212;
                  отладочные сообщения показываются для серьёзных
                  ошибок.
                </li><li><code class="option">misc</code>&nbsp;&#8212;
                  отладочные сообщения выводятся для различных ошибок
                  (помогает узнать состояние системы <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-scrubbing" title="C.2.2.2. Нормализация трафика (Scrub)">нормализации
                    трафика (scrub)</a> и ошибки в работе таблицы
                  состояний);
                </li><li><code class="option">loud</code>&nbsp;&#8212;
                  Отладочные сообщения общего плана (позволяет изучать
                  сообщения от системы <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-osfp" title="C.2.1.4.12. Пассивное детектирование операционной системы">osfp</a>).
                </li></ul></div><p>
                Умолчание&nbsp;&#8212; <code class="option">urgent</code>. Уровень
                отладки можно также изменять при помощи команды
                <span><strong class="command">pfctl(8)</strong></span> (опция <code class="option">-x</code>,
                см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs03.html" title="C.3. Управление пакетным фильтром OpenBSD
      при помощи утилиты pfctl(8)">Раздел&nbsp;C.3, &#171;Управление пакетным фильтром <span class="acronym">OpenBSD</span>
      при помощи утилиты <span><strong class="command">pfctl(8)</strong></span>&#187;</a>).
              </p></dd><dt><span class="term"><code class="option">set fingerprints</code> file</span></dt><dd>
              Установить файл, из которого будет взята информация для
              системы <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-osfp" title="C.2.1.4.12. Пассивное детектирование операционной системы">osfp</a>.
              Умолчание&nbsp;&#8212; <code class="filename">/etc/pf.os</code>.
            </dd><dt><span class="term"><code class="option">set limit</code> option value</span></dt><dd><p>
                Установить предел для различных опций:
              </p><div class="itemizedlist"><ul type="disc"><li><code class="option">frags</code>&nbsp;&#8212;
                  Максимальное количество записей в пуле отвечающем за
                  <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-scrubbing" title="C.2.2.2. Нормализация трафика (Scrub)">нормализацию
                    трафика (scrub)</a>. По умолчанию&nbsp;&#8212;
                  <code class="option">100</code>.
                </li><li><code class="option">src-nodes</code>&nbsp;&#8212;
                  Максимальное количество записей в пуле отвечающем за
                  отслеживание исходящих IP адресов. (Пул генерируется
                  правилами с ключевыми словами
                  <code class="option">sticky-address</code>и
                  <code class="option">source-track</code>).
                  Умолчание&nbsp;&#8212; <code class="option">10000</code>.
                </li><li><code class="option">states</code>&nbsp;&#8212;
                  Максимальное количество вхождений в пул отвечающий за
                  состояние таблицы состояний соединений (Которая
                  заводится при помощи правил с ключевой фразой
                  <code class="option">keep&nbsp;state</code>, см.
                  <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-filter" title="C.2.1.4. Фильтрация пакетов">Раздел&nbsp;C.2.1.4, &#171;Фильтрация пакетов&#187;</a>). Умолчание
                  <code class="option">10000</code>.
                </li></ul></div><p>
                Допустим синтаксис: <code class="code">set limit {
                  states 20000, frags 20000, src-nodes 2000 }</code>
              </p></dd><dt><span class="term"><code class="option">set loginterface</code> interface</span></dt><dd><p>
                Задать интерфейс для которого пакетный фильтр собирает
                статистическую информацию: количество прошедших пакетов,
                количество заблокированных пакетов, сколько байт вошло,
                сколько вышло. Статистику можно собирать одновременно
                только на одном интерфейсе.  При этом, счётчики <code class="code">match</code>, <code class="code">bad-offset</code> и&nbsp;т.п., а также
                счётчики в таблице состояний, работают независимо от
                этой опции.  Чтобы отключить сбор статистики следует
                выставить опцию в <code class="option">none</code>. Значение по
                умолчанию&nbsp;&#8212; <code class="option">none</code>.
              </p><p>
                Просмотреть статистику можно при помощи команды
                <span><strong class="command">pfctl(8)</strong></span> с опцией
                <code class="option">-s&nbsp;info</code>.
                См. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs03.html#pfctl-ex1" title="Пример C.1. Просмотр статистики на интерфейсе выбранном при помощи
          опции loginterface">Пример&nbsp;C.1, &#171;Просмотр статистики на интерфейсе выбранном при помощи
          опции <code class="option">loginterface</code>&#187;</a>
              </p></dd><dt><span class="term"><code class="option">set releset-optimization</code> value</span></dt><dd><p>
                Это усовершенствование введено в
                <span class="acronym">OpenBSD</span>&nbsp;4.1 и пока ещё нигде не
                внедрено. Оптимизацию теперь можно задавать
                непосредственно в <code class="filename">pf.conf(5)</code>, а не
                только как опцию <span><strong class="command">pfctl(8)</strong></span> (см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs03.html" title="C.3. Управление пакетным фильтром OpenBSD
      при помощи утилиты pfctl(8)">Раздел&nbsp;C.3, &#171;Управление пакетным фильтром <span class="acronym">OpenBSD</span>
      при помощи утилиты <span><strong class="command">pfctl(8)</strong></span>&#187;</a>, опция <code class="option">-o</code>).
              </p><p>
                <code class="option">value</code> может принимать следующие
                значения:
              </p><div class="variablelist"><dl><dt><span class="term"><code class="option">none</code></span></dt><dd>
                    Отключить оптимизацию
                  </dd><dt><span class="term"><code class="option">basic</code></span></dt><dd><p>
                      Выполняет следующую оптимизацию: 1)&nbsp;удаляет
                      дублирующиеся правила; 2)&nbsp;удаляет правила,
                      являющиеся подмножеством других правил;
                      3)&nbsp;объединяет несколько правил в таблицу, где
                      это возможно; 4)&nbsp;пересортирует правила для
                      лучшей производительности.
                    </p><p>
                      То же достигается указанием опции
                      <code class="option">-o</code> команды
                      <span><strong class="command">pfctl(8)</strong></span>.
                    </p></dd><dt><span class="term"><code class="option">profile</code></span></dt><dd>
                      Вставляет где можно опцию <code class="option">quick</code>.
                      Того же эффекта можно добиться при помощи двух
                      опций <code class="option">-oo</code> в программе
                      <span><strong class="command">pfctl(8)</strong></span>.
                    </dd></dl></div><p>
                При оптимизации может измениться порядок правил, что
                может привести к нарушению в работе биллинговой системы.
                Для предотвращения оптимизации можно расставлять в
                правилах метки <code class="code">label</code>.
              </p></dd><dt><span class="term"><code class="option">set optimization</code> value</span></dt><dd><p>
                Установить оптимизацию пакетного фильтра для различного
                поведения сети:
              </p><div class="itemizedlist"><ul type="disc"><li><code class="option">normal</code>&nbsp;&#8212;
                  подходит ко всем сетям.
                </li><li><code class="option">high-latency</code>&nbsp;&#8212;
                  подходит для сетей работающих с большими задержками,
                  например через спутник.
                </li><li><code class="option">aggressive</code>&nbsp;&#8212;
                  агрессивно очищать таблицу состояний. Это может
                  существенно уменьшить требования к памяти на
                  загруженном брандмауэре, однако связано с риском
                  преждевременного разрыва соединений.
                </li><li><code class="option">conservative</code>&nbsp;&#8212;
                  крайне консервативный брандмауэр. Предотвращает разрыв
                  соединений, однако приводит к большому расходу памяти.
                </li></ul></div><p>
                Умолчание&nbsp;&#8212;<code class="option">normal</code>
              </p></dd><dt><span class="term"><code class="option">set skip on</code> interface</span></dt><dd>
              Полностью игнорировать указанный интерфейс. Имеет смысл
              использоать для кольцевого интерфейса, где не требуется ни
              фильтрации трафика, ни нормализации. Опция может
              задаваться несколько раз, по умолчанию не установлена.
            </dd><dt><span class="term"><code class="option">set state-policy</code> value</span></dt><dd><p>
                Поведение пакетного фильтра при использовании таблицы
                состояний (см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-filter" title="C.2.1.4. Фильтрация пакетов">Раздел&nbsp;C.2.1.4, &#171;Фильтрация пакетов&#187;</a>).
                Это поведение может быть переопределено в конкретных
                правилах фильтрации:
              </p><div class="itemizedlist"><ul type="disc"><li><code class="option">if-bound</code>&nbsp;&#8212; Состояние
                  привязывается к конкретному интерфейсу, через который
                  прошёл первый пакет. Если ответ пришёл через другой
                  интерфейс, он не будет соответствовать данному
                  соединению.
                </li><li><code class="option">group-bound</code>&nbsp;&#8212; то же, но
                  привязано к группе интерфейсов (в
                  <span class="acronym">OpenBSD</span>, но не в
                  <span class="acronym">FreeBSD</span>, интерфейсы можно объединять
                  в группы).
                </li><li><code class="option">floating</code>&nbsp;&#8212; Записи в
                  таблице состояний не привязаны к интерфейсам.
                </li></ul></div><p>
                Умолчание&nbsp;&#8212; <code class="option">floating</code>
              </p></dd><dt><span class="term"><code class="option">set timeout</code> option value</span></dt><dd><p>
                Задаёт таймауты в секундах:
              </p><div class="variablelist"><dl><dt><span class="term"><code class="option">interval</code></span></dt><dd>
                    Задержка перед удалением истекшей записи или
                    истекшего фрагмента пакета. Т.е. после того, как
                    соединение закрылось и запись <span class="emphasis"><em>может
                      быть</em></span> удалена из таблицы состояний,
                    пройдёт ещё <code class="option">interval</code> секунд, прежде
                    чем запись <span class="emphasis"><em>будет</em></span> удалена из
                    таблицы состояний.  Умолчание&nbsp;&#8212;
                    <code class="option">10</code></dd><dt><span class="term"><code class="option">fragment</code></span></dt><dd>
                    по истечении данного интервала времени
                    фрагментированный пакет будет отброшен, если не
                    придёт следующий фрагмент. По
                    умолчанию&nbsp;&#8212; <code class="option">30</code>.
                  </dd><dt><span class="term"><code class="option">src.track</code></span></dt><dd>
                    Сколько времени хранить в памяти информацию об
                    исходящих IP для работы source tracking (см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rule-state-opts" title="C.2.1.4.7. Опции таблицы состояний">Раздел&nbsp;C.2.1.4.7, &#171;Опции таблицы состояний&#187;</a>) после
                    удаления записи из таблицы состояний. По
                    умолчанию&nbsp;&#8212;<code class="option">0</code>.
                  </dd><dt><span class="term"><code class="option">proto.modifier</code></span></dt><dd><p>
                      Время в течение которого в таблице состояний
                      хранится запись о коннекте. Здесь
                      <code class="option">proto</code> может быть
                      <code class="option">tcp</code>, <code class="option">udp</code>,
                      <code class="option">icmp</code> или что-то (здесь
                      <code class="option">other</code>), а
                      <code class="option">modifier</code> указывает на состояние
                      коннекта. Конкретнее:
                    </p><p>
                      <span class="acronym">TCP</span>:
                    </p><div class="variablelist"><dl><dt><span class="term"><code class="option">tcp.first</code></span></dt><dd>
                          Состояние после прохода первого пакета (SYN)
                        </dd><dt><span class="term"><code class="option">tcp.opening</code></span></dt><dd>
                          Состояние после того как хост назначения
                          ответит пакетом (SYN,ACK)
                        </dd><dt><span class="term"><code class="option">tcp.established</code></span></dt><dd>
                          Состояние TCP ESTABLISHED
                        </dd><dt><span class="term"><code class="option">tcp.closing</code></span></dt><dd>
                          Состояние после прохода первого пакета с
                          флагом FIN.
                        </dd><dt><span class="term"><code class="option">tcp.finwait</code></span></dt><dd>
                          Состояние после того, как обе стороны
                          переслали друг другу пакеты FIN. Соединение в
                          этот момент считается, закрытым, но по нему
                          ещё могут пройти дополнительные пакеты FIN.
                        </dd><dt><span class="term"><code class="option">tcp.closed</code></span></dt><dd>
                          Состояние после того, как одна из сторон
                          передаст пакет с флагом RST.
                        </dd></dl></div><p>
                      <span class="acronym">UDP</span>:
                    </p><div class="variablelist"><dl><dt><span class="term"><code class="option">udp.first</code></span></dt><dd>
                          Состояние после прохода первого пакета
                        </dd><dt><span class="term"><code class="option">udp.single</code></span></dt><dd>
                          Состояние в которое попадает соединение если
                          источник послал более одного пакета, а хост
                          назначения не передал в ответ ни одного.
                        </dd><dt><span class="term"><code class="option">udp.multiple</code></span></dt><dd>
                          Состояние в которое попадает соединение, если
                          и источник и и хост назначения обмениваются
                          пакетами в обе стороны.
                        </dd></dl></div><p>
                      <span class="acronym">ICMP</span>:
                    </p><div class="variablelist"><dl><dt><span class="term"><code class="option">icmp.first</code></span></dt><dd>
                          Состояние после прохода первого пакета
                        </dd><dt><span class="term"><code class="option">icmp.error</code></span></dt><dd>
                          Состояние в которое попадает соединение, если
                          в ответ на пакет <span class="acronym">ICMP</span>
                          приходит сообщение об ошибке.
                        </dd></dl></div><p>
                      Прочие протоколы обрабатываются как и
                      <span class="acronym">UDP</span>:
                      <code class="option">other.first</code>,
                      <code class="option">other.single</code>,
                      <code class="option">other.multiple</code>
                    </p></dd><dt><span class="term"><code class="option">set adaptive.start</code> value</span></dt><dd>
                    Если число записей в таблице состояний превысило
                    указанный в данной опции предел, надо приступить к
                    уменьшению таймаутов: Все таймауты умножаются на
                    величину  (<code class="option">adaptive.end</code> -
                    количество_записей_в_табилце_состояний) /
                    (<code class="option">adaptive.end</code> -
                    <code class="option"> adaptive.start</code>)
                  </dd><dt><span class="term"><code class="option">set adaptive.end</code> value</span></dt><dd>
                    Если число записей достигает этой величины, все
                    таймауты обращаются в ноль и таблица состояний
                    очищается. Данный предел не должен достигаться в
                    норме. Он указывается только как scale-фактор, для
                    формулы приведённой выше.
                  </dd></dl></div><p>
                Пример: пусть в <code class="filename">pf.conf(5)</code>
                написано:
              </p><div class="informalexample"><pre class="programlisting">set timeout tcp.first 120
set timeout tcp.established 86400
set timeout { adaptive.start 6000, adaptive.end 12000 }
set limit states 10000
                </pre></div><p>
                Тогда, если количество записей в таблице сотояний
                достигло 9000, то все таймауты будут уменьшены на 50%, в
                частности <code class="option">tcp.first</code> будет равен 30
                секунд, а <code class="option">tcp.established</code> 43200 секунд.
              </p></dd></dl></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-scrubbing"></a>C.2.2.2. Нормализация трафика (Scrub)</h4></div></div></div><p>
          Нормализация трафика нужна для того, чтобы исключить
          неопределённость с тем куда направляется пакет. Кроме того,
          при нормализации собираются вместе фрагментированные пакеты,
          происходит защита операционных систем от некоторого вида атак
          и отбрасываются TCP пакеты с невозможным сочетанием флагов.
          Простейшая директива выглядит так:
        </p><div class="informalexample"><pre class="programlisting">scrub in all
          </pre></div><p>
          Это приводит к нормализации всего входящего трафика на всех
          интерфейсах.
        </p><p>
          Одна из возможных причин для неиспользования
          нормализации&nbsp;&#8212; использование NFS. Некоторые не
          <span class="acronym">OpenBSD</span> платформы используют странные
          пакеты&nbsp;&#8212; фрагментированные, но с выставленным
          битом &#171;нефрагментировано&#187;, которые должны
          отбрасываться пакетным фильтром при нормализации. Эту проблему
          можно разрешить при использовании опции
          <code class="option">no-df</code>. Другая причина может состоять в том,
          что некоторые многопользовательские сетевые игры блокируются
          пакетным фильтром с запущенным нормализатором. Во всех
          остальных случаях, кроме приведённых весьма необычных
          ситуаций, нормализация трафика крайне желательна.
        </p><p>
          Синтаксис директивы <code class="option">scrub</code> весьма напоминает
          синтаксис правил фильтрации (см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-filter" title="C.2.1.4. Фильтрация пакетов">Раздел&nbsp;C.2.1.4, &#171;Фильтрация пакетов&#187;</a>). Как и в случае с NAT
          трансляцией, <span class="emphasis"><em>первое правило выигрывает</em></span>.
          Перед директивой <code class="option">scrub</code> можно употреблять
          ключевое слово <code class="option">no</code>, чтобы указанные пакеты не
          нормализовались.
        </p><p>
          Scrub имеет следующие опции:
        </p><div class="variablelist"><dl><dt><span class="term"><code class="option">no-df</code></span></dt><dd>
              Очищает бит &#171;нефрагментировано&#187; из заголовка IP.
              Про некоторые операционные системы известно, что они
              выставляют этот бит на фрагментированных пакетах при
              работе с NFS. Нормализатор будет отбрасывать такие пакеты,
              если не указана данная опция. Поскольку некоторые
              операционные системы генерируют такие пакеты с нулевым
              идентификатором IP, рекомендуется употреблять данную опцию
              вместе с опцией <code class="option">random-id</code>.
            </dd><dt><span class="term"><code class="option">random-id</code></span></dt><dd>
              Замещать идентификатор IP случайным значением для
              компенсации некоторых систем использующих предсказуемые
              идентификаторы. Опция может применяться только к
              нефрагментированным пакетам.
            </dd><dt><span class="term"><code class="option">min-ttl</code> num</span></dt><dd>
              Выставить минимальный TTL в пакете IP.
            </dd><dt><span class="term"><code class="option">max-mss</code> num</span></dt><dd>
              Выставить максимальный размер сегмента в заголовке IP.
            </dd><dt><span class="term"><code class="option">fragment reassemble</code></span></dt><dd>
              Буферизовать входящий трафик и собирать вместе
              фрагментированные пакеты перед отправкой на правила
              фильтра. Выигрыш в том, что фильтр имеет дело с заведомо
              нефрагментированным трафиком и видит пакет целиком.
              Проигрыш в расходе памяти и замедлении прохождения пакетов
              через пакетный фильтр.
            </dd><dt><span class="term"><code class="option">fragment crop</code></span></dt><dd>
              В норме, при фрагментации IP пакетов они должны нарезаться
              на части без перехлёстов. Если фрагменты повторяются или
              накладываются, это не нормальная ситуация. В таком случае
              можно сделать одно из двух: либо повторы выкинуть, а
              накладывающиеся фрагменты обрезать, либо выкинуть и то и
              другое по параноидальным соображениям. Первое делает опция
              <code class="option">fragment crop</code>, второе&nbsp;&#8212;
              <code class="option">fragment drop-ovl</code>. В обоих случаях пакеты
              не буферизируются как в случае <code class="option">fragment
                reassemble</code>.
            </dd><dt><span class="term"><code class="option">fragment drop-ovl</code></span></dt><dd>
              Выбрасывать пакеты в которых происходят повторы и
              наложения (см. пояснение в предыдущей опции).
            </dd><dt><span class="term"><code class="option">reassemble tcp</code></span></dt><dd><p>
                Нормализация соединений TCP на основе таблицы состояний.
                При использовании данной опции нельзя указывать
                направление <code class="code">in/out</code>.
                Осуществляется следующая нормализация:
              </p><div class="itemizedlist"><ul type="disc"><li>
                  Ни одна из сторон не может занижать TTL. Это нужно для
                  предотвращения атак на брандмауэр, когда злоумышленник
                  занижает TTL  с целью замусорить таблицу состояний.
                  TTL выставляется в наивысшее значение случившееся во
                  время коннекта.
                </li><li>
                  Выставляется случайный timestamp в заголовке IP, с
                  тем, чтобы злоумышленник не мог догадаться как много
                  машин находится за шлюзом с NAT.
                </li></ul></div></dd></dl></div><p>
          Пример:
        </p><div class="informalexample"><pre class="programlisting">scrub in on fxp0 all fragment reassemble min-ttl 15 max-mss 1400
scrub in on fxp0 all no-df
scrub    on fxp0 all reassemble tcp
          </pre></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-anchors"></a>C.2.2.3. Anchors</h4></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Замечание]" src="pf_02_files/note.png"></td><th align="left">Замечание</th></tr><tr><td valign="top" align="left">
          Все мои попытки перевести это слово на руссий язык увенчались
          неудачей. Смысл при переводе полностью утрачивается, поэтому я
          буду употреблять слово anchor. Если что, то дословный
          перевод&nbsp;&#8212; якорь. Смысл примерно такой:
          якорь&nbsp;&#8212; это место куда подгружается поднабор
          правил и одновременно якорь это имя поднабора. Данный здесь
          текст частично основан на переводе выполненном Михаилом
          Сгибневым. Михаил словом &#171;якорь&#187; называл точку
          привязки правил, а поднабор правил Михаил называл
          &#171;именованный поднабор правил&#187;. Я сохранил этот стиль
          в данном подразделе.
        </td></tr></tbody></table></div><p>
          Вдобавок к обычным наборам правил пакетный фильтр может
          использовать поднаборы. Если <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-tables" title="C.2.1.3. Таблицы">таблицы</a> можно
          использовать для динамической смены на лету наборов IP-адресов,
          то поднаборы правил можно использовать для динамического
          переконфигурирования брандмауэра. С их помощью можно менять
          наборы правил фильтра, nat, binat и rdr.
        </p><p>
          Поднаборы правил можно объявлять при помощи
          &#171;якорей&#187;,&nbsp;&#8212; anchor
          Существует четыре типа anchor'ов:
        </p><div class="itemizedlist"><ul type="disc"><li><code class="option">anchor</code> name&nbsp;&#8212; выполняются все
            правила <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-filter" title="C.2.1.4. Фильтрация пакетов">фильтра</a> из
            набора name;
          </li><li><code class="option">binat-anchor</code> name&nbsp;&#8212; выполняются все
            правила <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-binat" title="C.2.1.5.5. Bidirectional mapping (соответствие 1:1)">binat трансляции</a> из
            набора name;
          </li><li><code class="option">nat-anchor</code> name&nbsp;&#8212; выполняются все
            правила <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-nat" title="C.2.1.5. NAT">nat трансляции</a> из
            набора name;
          </li><li><code class="option">rdr-anchor</code> name&nbsp;&#8212; выполняются все
            правила <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-rdr" title="C.2.1.6. Перенаправление пакетов, проброс портов">перенаправления</a> из
            набора name;
          </li></ul></div><p>
          Поднаборы могут быть вложенными и вызывать друг друга по
          цепочке. Правила anchor обрабатываются в том месте, где они
          вызываются. Например, правило <code class="option">anchor</code> в
          основном конфигурационном файле создаёт поднабор, родителем
          которого являентся главный набор правил, другие поднаборы
          загружаемые в данном поднаборе при помощи директивы
          <code class="option">load&nbsp;anchor</code> являются его потомками.
        </p><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-anchors-desc"></a>C.2.2.3.1. Именованные наборы правил</h5></div></div></div><p>
            Именованный набор&nbsp;&#8212; это группа правил
            фильтрации, и/или правил трансляции, которым
            было назначено имя.  Когда пакетный фильтр обнаруживает
            якорь в главном наборе правил, он производит проверку всех
            поднаборов правил привязанных к нему.
          </p><p>
            Пример:
          </p><div class="informalexample"><pre class="screen">ext_if = "fxp0"

block on $ext_if all
pass  out on $ext_if all keep state
anchor goodguys
            </pre></div><p>
            Этот набор правил устанавливает по умолчанию запретительную
            политику на интерфейсе <code class="code">fxp0</code> для
            всего входящего и исходящего трафика. Разрешается весь
            исходящий трафик и подгружается именованный набор правил
            goodguys.  Якоря могут быть связаны с правилами двумя
            методами:
          </p><div class="itemizedlist"><ul type="disc"><li>
              Используя правило <code class="code">load</code></li><li>
              Используя <span><strong class="command">pfctl(8)</strong></span></li></ul></div><p>
            Загрузка правил указывает <span><strong class="command">pfctl(8)</strong></span>
            загрузить правила из текстового файла. Например: 
          </p><div class="informalexample"><pre class="programlisting">load anchor goodguys:ssh from "/etc/anchor-goodguys-ssh"
            </pre></div><p>
            Когда будет загружен главный набор, правила, перечисленные в
            файле <code class="filename">/etc/anchor-goodguys-ssh</code> будут
            загружены в именованный набор <code class="code">ssh</code>, ассоциированный с якорем <code class="code">goodguys</code>. 
          </p><p>
            Используя <span><strong class="command">pfctl(8)</strong></span> можно добавить правило
            к якорю:
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> echo "pass in proto tcp from 192.0.2.3 to any port 22" | pfctl -a goodguys:ssh -f -
            </pre></div><p>
            Таким образом, мы добавляем правило <code class="code">pass</code> к именованному набору <code class="code">ssh</code> связанному с якорем <code class="code">goodguys</code>. Пакетный фильтр будет
            проверять эти правила, когда доберётся до якоря <code class="code">goodguys</code>.
          </p><p>
            Правила также могут быть сохранены и загружены из текстового файла: 
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> cat &gt;&gt; /etc/anchor-goodguys-www
pass in proto tcp from 192.0.2.3 to any port 80
pass in proto tcp from 192.0.2.4 to any port { 80 443 }
<code class="prompt">#</code> pfctl -a goodguys:www -f /etc/anchor-goodguys-www
            </pre></div><p>
            Эта операция загрузит правила из файла
            <code class="filename">/etc/anchor-goodguys-www</code> в именованый
            набор правил <code class="code">www</code> якоря
            <code class="code">goodguys</code>. 
          </p><p>
            Поскольку наборы правил могут быть вложенными, существует
            возможность вызвать все правила вложенные в некоторый набор:
          </p><div class="informalexample"><pre class="programlisting">anchor "spam/*"
            </pre></div><p>
            Синтаксис правил в подгружаемых наборах правил такой же как
            и в главном наборе правил, но все используемые <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-macro" title="C.2.1.2. Макросы">макросы</a> должны быть
            определены в пределах этого же набора: макросы, определённые
            в главном наборе не видны из именованного набора. 
          </p><p>
            Каждый именованный набор существует обособленно от
            остальных. Операции, проводимые над ним, такие как сброс
            правил, не имеют эффекта над остальными. Кроме того,
            удаление указателя на якорь не приводит к удалению ни самого
            якоря ни привязанных к нему именованных наборов правил.
            Именованный набор существует до тех пор, пока все его
            правила не будут сброшены, используя
            <span><strong class="command">pfctl(8)</strong></span>. Якорь уничтожается как только
            не остается ни одного привязанного к нему набора правил. 
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-anchors-option"></a>C.2.2.3.2. Опции якоря</h5></div></div></div><p>
            Правило <code class="code">anchor</code> позволяет так же
            указать интерфейс, протокол, адреса источника и назначения и
            прочее. Синтаксис аналогичен синтаксису правил фильтрации.
            Если эта информация есть, то набор правил соответствующих
            якорю используется для пакета только данные критерии
            удовлетворены:
          </p><div class="informalexample"><pre class="programlisting">ext_if = "fxp0"

block on $ext_if all
pass  out on $ext_if all keep state
anchor ssh in on $ext_if proto tcp from any to any port 22
            </pre></div><p>
            Правила из якоря <code class="code">ssh</code> будут
            использоваться только если пакет был TCP и пришёл на 22-й
            порт через интерфейс <code class="code">fxp0</code>.
            Правила к якорю могут добавляться так: 
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> echo "pass in from 192.0.2.10 to any" | pfctl -a ssh:allowed -f -
            </pre></div><p>
            Несмотря на то, что в правиле не определён ни порт, ни
            протокол, ни интерфейс, хосту 192.0.2.10 будет разрешена
            работа только по протоколу ssh, в силу определений сделанных
            при объявлении якоря.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-anchors-manipulating"></a>C.2.2.3.3. Управление именованными наборами</h5></div></div></div><p>
            Управление именованными наборами правил осуществляется при
            помощи утилиты <span><strong class="command">pfctl(8)</strong></span>. Она позволяет
            удалять и добавлять правила в набор без перезагрузки
            главного набора правил.
          </p><p>
            Вывести список правил из набора <code class="code">ssh</code>:
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> pfctl -a ssh -s rules
            </pre></div><p>
            Сбросить набор правил <code class="code">ssh</code>:
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> pfctl -a ssh -F rules
            </pre></div></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-queue"></a>C.2.2.4. Очереди, приоритеты (регулировка полосы пропускания)</h4></div></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-queue-queue"></a>C.2.2.4.1. Очереди</h5></div></div></div><p>
            Поставить что-то в очередь, значит сохранить это до
            обработки. При работе в сети, данные получаемые хостом
            поступают в очередь и ждут, когда они будут обработаны
            операционной системой, при этом она решает, какие именно
            пакеты и в каком порядке обрабатывать. Изменение порядка
            обработки пакетов может оказать влияние на
            производительность сети. В идеальном случае, пакеты ssh
            должны обрабатываться в первую очередь, так как этот
            протокол очень чувствителен к задержкам. При нажатии клавиши
            в ssh-клиенте ожидается немедленный ответ, но идущая
            передача по ftp вызывает задержку в несколько секунд. Что
            может произойти в случае, когда роутер обрабатывает большое
            количество ftp пакетов? Пакеты ssh сохраняются в очереди, а
            то и просто отбрасываются в случае малого буфера и в
            результате ssh сессия может вообще прерваться. Изменение
            стратегии организации очередей может позволить распределить
            пропускную способность между различными приложениями,
            пользователями и хостами. 
          </p><p>
            Обратите внимание, что организация очереди имеет смысл
            только для исходящих соединений, потому что как только пакет
            попал на входящий интерфейс с ним уже поздно что-либо
            делать, так как полоса пропускания канала была уже
            использована. Единственным решением этой проблемы может
            стать организация очереди на смежном маршрутизаторе или
            позволять организацию очереди на внутреннем интерфейсе, если
            хост сам является смежным маршрутизатором. 
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-queue-sheduler"></a>C.2.2.4.2. Планировщики</h5></div></div></div><p>
            Планировщиком называется то, что организовывает очередь и
            определяет порядок обработки пакетов. По умолчанию в
            <span class="acronym">OpenBSD</span> в качестве планировщика
            используется <span class="acronym">FIFO</span>, очередь.
            Принцип её работы очень прост&nbsp;&#8212; первый
            вошёл&nbsp;&#8212; первый вышел. Новоприбывший пакет
            добавляется в конец очереди. При превышении максимального
            размера очереди пакет отбрасывается. Это явление известно
            как tail-drop (отброс хвоста, как у ящерицы). 
          </p><p>
            Есть и другие планировщики. <span class="acronym">OpenBSD</span> (и
            <span class="acronym">FreeBSD</span>) поддерживает ещё три
            планировщика:
          </p><div class="itemizedlist"><ul type="disc"><li>
              Очереди основанные на классах (Class Based Queueing,
              <span class="acronym">CBQ</span>)
            </li><li>
              Приоритетные очереди (Priority Queueing,
              <span class="acronym">PRIQ</span>)
            </li><li><span class="acronym">HFSC</span> (Hierarchical Fair Service Curve).
              По смыслу этот сервис очень похож на
              <span class="acronym">CBQ</span>. На русский переводится примерно
              так: иерархические очереди основанные на подробно
              вычерченных кривых трафика. См. пояснения в <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-queue-sheduler-HFSC" title="C.2.2.4.2.3. HFSC">Раздел&nbsp;C.2.2.4.2.3, &#171;HFSC&#187;</a></li></ul></div><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-queue-sheduler-CBQ"></a>C.2.2.4.2.1. Очереди базирующиеся на классах</h6></div></div></div><p>
              В очередях базирующиеся на классах
              (<span class="acronym">CBQ</span>) алгоритм организации очереди
              построен на разделении полосы пропускания между различными
              очередями или классами.  Трафик присоединяется к очереди
              на основании адреса источника или отправителя, порта,
              протокола и т.д.  Очередь может быть сконфигурирована на
              заимствование произвольной полосы пропускания от
              родительской очереди, если та занимает свой канал не
              полностью. Очереди также могут работать с системой
              приоритетов, например, пропуская ssh трафик в первую
              очередь, по сравнению с трафиком ftp.
            </p><p>
              В <span class="acronym">CBQ</span> очереди размещаются иерархическим
              способом. В самом верху&nbsp;&#8212; родительская
              очередь, определяющая общую пропускную способность.
              Дочерним очередям назначается некоторая часть от полосы
              пропускания родительской очереди. Например, очереди могут
              быть определены следующим способом:
            </p><div class="informalexample"><pre class="programlisting">Root Queue (2Mbps)

   Queue A (1Mbps)
   Queue B (500kbps)
   Queue C (500kbps)
              </pre></div><p>
              Здесь общая полоса пропускания&nbsp;&#8212; 2 мегабита в
              секунду (megabits per second&nbsp;&#8212; Mbps), Которая
              разделена на три подочереди.
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Замечание]" src="pf_02_files/note.png"></td><th align="left">Замечание</th></tr><tr><td valign="top" align="left">
              Полосу пропускания обычно измеряют в битах в секунду. При
              этом 1000&nbsp;bps = 1&nbsp;kbps, 1000&nbsp;kbps =
              1&nbsp;Mbps. 1&nbsp;Mbps = 125000 байт в секунду или 122
              килобайта в секунду.
            </td></tr></tbody></table></div><p>
              Иерархия может быть расширена с использованием
              вложенности. Для того, чтобы разделить полосу пропускания
              между различными пользователями, при этом сделав так, что
              бы различные виды трафика не мешали друг другу, можно
              создать следующую структуру очередей: 
            </p><div class="informalexample"><pre class="programlisting">Root Queue (2Mbps)

   UserA (1Mbps)

      ssh (50kbps)
      bulk (950kbps)

   UserB (1Mbps)

       audio (250kbps)
       bulk (750kbps)

          http (100kbps)
          other (650kbps)
              </pre></div><p>
              Обратите внимание, что на каждом уровне сумма полос
              пропускания не может быть больше родительской. 
            </p><p>
              Очередь может быть настроена таким образом, что будет
              заимствовать (borrow) полосу пропускания у родителя в
              случае неиспользования ее другими очередями. Рассмотрим
              такую организацию очереди: 
            </p><div class="informalexample"><pre class="programlisting">Root Queue (2Mbps)

   UserA (1Mbps)

      ssh (100kbps)
      ftp (900kbps, borrow)

UserB (1Mbps)
              </pre></div><p>
              Если трафик в очереди ftp превышает 900&nbsp;kbps, а
              трафик в очереди UserA&nbsp;&#8212; меньше чем
              1&nbsp;Mbps (потому что очередь ssh использует меньше чем
              100&nbsp;kbps), полоса пропускания ftp может быть
              увеличена. Таким образом очередь ftp способна использовать
              больше чем назначенные ей 900&nbsp;kbps, но в случае
              увеличения очереди ssh заимствованая полоса освобождается. 
            </p><p>
              CBQ может назначать каждой группе определённый приоритет. В
              моменты перегрузки предпочтение отдается очередям с более
              высоким приоритетом в случае наличия у них одного
              родителя. При одинаковых приоритетах очереди обслуживаются
              циклически. Для примера: 
            </p><div class="informalexample"><pre class="programlisting">Root Queue (2Mbps)

  UserA (1Mbps, priority 1)

     ssh (100kbps, priority 5)
     ftp (900kbps, priority 3)

UserB (1Mbps, priority 1)
              </pre></div><p>
              Очереди UserA и UserB будут обрабатываться циклически, так
              как их приоритеты равны. В случае перегрузки в сети,
              предпочтение будет отдаваться ssh, так как её приоритет
              больше, чем у очереди ftp. При этом очереди ssh и ftp не
              имеют приоритета перед очередями UserA и UserB, так как
              они находятся на более низком уровне.
            </p><p>
              Детальная информация о <span class="acronym">CBQ</span> приведена в
              <a href="http://www.icir.org/floyd/cbq.html" target="_top">References
                on CBQ</a>.
            </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-queue-sheduler-PRIQ"></a>C.2.2.4.2.2. Приоритетные очереди</h6></div></div></div><p>
              Приоритетные очереди (<span class="acronym">PRIQ</span>) создаются
              на сетевом интерфейсе, причем структура очередей является
              плоской&nbsp;&#8212; нельзя создавать дочерние очереди.
              Сперва определяется корневая очередь с указанием общей
              пропускной способности, а за ней все дочерние очереди.
              Например: 
            </p><div class="informalexample"><pre class="programlisting">Root Queue (2Mbps)

   Queue A (priority 1)
   Queue B (priority 2)
   Queue C (priority 3)
              </pre></div><p>
              Пропускная способность основной очереди определена как
              2&nbsp;Mbps, следом идут дочерние. 
            </p><p>
              При использовании <span class="acronym">PRIQ</span> вы должны очень
              тщательно планировать очереди, так как они обрабатываются
              строго по приоритетам и если трафик с высоким приоритетом
              займёт весь канал, пакеты принадлежащие трафику с низким
              приоритетом будут отбрасываться.
            </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-queue-sheduler-HFSC"></a>C.2.2.4.2.3. HFSC</h6></div></div></div><p>
              Очереди закреплённые за интерфейсом выстраиваются в
              иерархическое древо, каждая очередь может иметь потомка.
              Каждая очередь может иметь свой приоритет и свою полосу
              пропускания. Этот вид очереди похож на <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-queue-sheduler-CBQ" title="C.2.2.4.2.1. Очереди базирующиеся на классах">CBQ</a>. Основное
              отличие <span class="acronym">HFSC</span> от <span class="acronym">CBQ</span>
              в том, что она позволяет отдельно регулировать задержки и
              пропускную способность очереди.
            </p><p>
              В <span class="acronym">CBQ</span> единственный параметр очереди это
              полоса пропускания. Если мы нарисуем &#171;кривую
              сервиса&#187; (прохождение пакетов по времени), то это
              будет некоторая прямая. Единственный способ снизить
              задержки при работе такой очереди состоит в том, чтобы
              увеличить полосу пропускания.
            </p><p>
              В <span class="acronym">HFSC</span> кривая сервиса состоит из двух
              линейных участков:
            </p><div class="mediaobject"><img src="pf_02_files/sample-sc1.gif" alt="Кривая service curve"><div class="caption">
                Кривая service curve. m1&nbsp;&#8212; наклон первого
                участка кривой, соответствует начальной полосе
                пропускания и, в совокупности с параметром d, позволяет
                регулировать задержки <span class="emphasis"><em>независимо</em></span> от
                полосы пропускания. d&nbsp;&#8212; время в течении
                которого действует полоса пропускания m1.
                m2&nbsp;&#8212; конечная полоса пропускания.
              </div></div><p>
              Дополнительная информация о <span class="acronym">HFSC</span> может
              быть найдена по адресу <a href="http://www.cs.cmu.edu/%7Ehzhang/HFSC/main.html" target="_top">http://www.cs.cmu.edu/~hzhang/HFSC/main.html</a>.
            </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-queue-RED"></a>C.2.2.4.2.4. Случайное раннее обнаружени (RED)</h6></div></div></div><p>
              Случайное раннее обнаружение (Random Early Detection,
              <span class="acronym">RED</span>)&nbsp;&#8212; это алгоритм
              определения перегрузки канала. Его целью является
              предотвращение переполнения очереди. Делается это путём
              непрерывного сравнения текущей длины очереди с минимальным
              и максимальным порогами. Если минимальный порог не
              достигнут&nbsp;&#8212; все пакеты пропускаются.  Если
              достигнут максимальные порог&nbsp;&#8212; все пакеты
              отбрасываются. В промежутке пакеты отбрасываются с
              определённой вероятностью, зависящей от размера очереди.
              Чем ближе к максимальному порогу&nbsp;&#8212; тем выше
              вероятность. Пакеты для отбрасывания выбираются случайным
              образом из разных сессий. Чем большая полоса пропускания
              занимается сессией, тем выше вероятность сброса из неё
              пакета. 
            </p><p>
              <span class="acronym">RED</span> весьма полезен, так как позволяет
              избежать ситуации, называемой &#171;глобальной
              синхронизацией&#187;, она проявляется в том, что связь
              полностью прекращается из-за одновременно отбрасываемых
              пакетов с разных сессий.  Например, если перегрузка
              происходит на маршрутизаторе, обслуживающем 10
              одновременных сессий ftp и будут отброшены пакеты от
              большинства или всех сессий, общая пропускная способность
              резко понизится. <span class="acronym">RED</span> позволяет избежать
              этого, выбирая сессии из которых терять пакеты случайным
              образом.  Поскольку сессии занимающие больше полосы
              пропускания имеют больший шанс на потерю пакета, то
              возможность возникновения перегрузки исчезнет и больших
              потерь трафика не произойдет. Кроме того,
              <span class="acronym">RED</span> позволяет обработать взрывной
              всплеск трафика, так как начинает отбрасывать пакеты до
              переполнения очереди. 
            </p><p>
              <span class="acronym">RED</span> должен использоваться только тогда,
              когда транспортный протокол способен реагировать на
              индикаторы перегрузки сети. В большинстве случаев это
              означает, что <span class="acronym">RED</span> должен применяться
              только к очередям TCP, а не к очередям UDP или ICMP. 
            </p><p>
              Детальная информация о <span class="acronym">RED</span> приведена в
              <a href="http://www.icir.org/floyd/red.html" target="_top">References
                on RED</a>.
            </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-queue-ECN"></a>C.2.2.4.2.5. Явное уведомление о перегрузке (ECN)</h6></div></div></div><p>
              Явное уведомление о перегрузке (<span class="acronym">ECN</span>)
              работает совместно с <span class="acronym">RED</span> и применяется
              для уведомления двух связанных хостов о перегрузке сети.
              Делается это разрешением <span class="acronym">RED</span> установить
              флаг в заголовке пакета, вместо того, чтобы отбросить
              пакет. Если удалённый хост поддерживает
              <span class="acronym">ECN</span> и читает флаги ECE и CWR, то он
              начинает снижать исходящий трафик (см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apbs01.html#tcp-flags" title="Таблица B.3. Флаги TCP">Таблица&nbsp;B.3, &#171;Флаги TCP&#187;</a>, [<a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/bi01.html#RFC-3168" title="[RFC-3168]">RFC-3168</a>]).
            </p></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-queue-conf"></a>C.2.2.4.3. Конфигурирование очереди</h5></div></div></div><p>
            Начиная с <span class="acronym">OpenBSD</span>&nbsp;3.0 Alternate
            Queueing (<span class="acronym">ALTQ</span>) стал частью
            основной системы, а с версии
            <span class="acronym">OpenBSD</span>&nbsp;3.3 <span class="acronym">ALTQ</span> был
            интегрирован в пакетный фильтр и, следовательно, портирован
            вместе с ним и в <span class="acronym">FreeBSD</span>. Реализация
            <span class="acronym">ALTQ</span> в <span class="acronym">OpenBSD</span> поддерживает
            планировщики <span class="acronym">CBQ</span> <span class="acronym">PRIQ</span> и
            <span class="acronym">RED</span> вместе с <span class="acronym">ECN</span>. 
          </p><p>
            Очереди конфигурируются в файле
            <code class="filename">/etc/pf.conf(5)</code>. Есть два типа
            директив, которые используются для конфигурирования
            очередей:
          </p><div class="variablelist"><dl><dt><span class="term"><code class="code">altq on</code></span></dt><dd>
                определяет интерфейс, на котором будет организована
                очередь и создаёт корневую очередь.
              </dd><dt><span class="term"><code class="code">queue</code></span></dt><dd>
                определяет свойства дочерних очередей.
              </dd></dl></div><p>
            Синтаксис директивы <code class="code">altq</code>:
          </p><div class="informalexample"><pre class="programlisting">altq on interface scheduler bandwidth bw qlimit qlim \
   tbrsize size queue { queue_list }
            </pre></div><div class="variablelist"><dl><dt><span class="term"><code class="code">interface</code></span></dt><dd>
                сетевой интерфейс на котором активируется очередь
              </dd><dt><span class="term"><code class="code">scheduler</code></span></dt><dd>
                какой планировщик будет использован. Доступные значения
                <code class="code">cbq</code> и <code class="code">priq</code>. На интерфейсе в один момент
                времени можно установить только один планировщик.
              </dd><dt><span class="term"><code class="code">bw</code></span></dt><dd>
                общая пропускная способность, доступная планировщику.
                Может содержать аббревиатуры b, Kb, Mb, Gb для
                обозначения bits, kilobits, megabits, и gigabits в
                секунду, конкретное значение или процент от общей
                пропускной способности.
              </dd><dt><span class="term"><code class="code">qlim</code></span></dt><dd>
                максимальное число пакетов в очереди. Необязательный
                параметр. По умолчанию&nbsp;&#8212; 50
              </dd><dt><span class="term"><code class="code">size</code></span></dt><dd>
                размер token bucket regulator в байтах. Если не
                определен, то устанавливается на основе ширины полосы
                пропускания.
              </dd><dt><span class="term"><code class="code">queue_list</code></span></dt><dd>
                список дочерних очередей, открываемых из под
                родительской очереди.
              </dd></dl></div><div class="blockquote"><blockquote class="blockquote"><p>
              Приведённый здесь текст является моим домыслом, и не имеет
              отношения к оригинальной документации по пакетному
              фильтру:
            </p><p>
              При регулировке полосы пропускания иногда применяют
              концепцию токенов: есть некоторая корзина (bucket) в
              которую регулярно, скажем раз в секунду, кладут билет
              (token). Пакет идущий сквозь очередь должен взять билет из
              корзины и проходить. Если билета в корине нет, пакет
              отбрасывается, если пакеты через очередь не идут, билеты
              копятся в корзине, пока она не переполнится.
            </p><p>
              Таким образом, если корзина очень большая, у нас после
              паузы в трафике могут наблюдаться резкие всплески. Если
              корзина маленькая&nbsp;&#8212; трафик будет равномерен,
              но малейшие флуктуации в скорости могут привести к отбросу
              пакетов.
            </p><p>
              Вот этот параметр и есть, по-видимому, token bucket
              regulator.
            </p></blockquote></div><p>
            Итак:
          </p><div class="informalexample"><pre class="programlisting">altq on fxp0 cbq bandwidth 2Mb queue { std, ssh, ftp }
            </pre></div><p>
            Это правило запускает <span class="acronym">CBQ</span> на интерфейсе
            <code class="code">fxp0</code>, пропускная способность
            канала 2&nbsp;Mb и создаются три дочерние очереди: std, ssh
            и ftp.
          </p><p>
            Синтаксис директивы <code class="code">queue</code>:
          </p><div class="informalexample"><pre class="programlisting">queue name [on interface] bandwidth bw [priority pri] [qlimit qlim] \
   scheduler ( sched_options ) { queue_list }
            </pre></div><div class="variablelist"><dl><dt><span class="term"><code class="code">name</code></span></dt><dd>
                имя очереди. Эта запись должна быть идентична
                определённой в директиве <code class="code">altq</code>
                опцией <code class="code">queue_list</code>. Для cbq
                это также может быть запись имени очереди в предыдущей
                директиве <code class="code">queue</code> параметре
                <code class="code">queue_list</code>. Имя не должно быть
                длиннее 15 символов.
              </dd><dt><span class="term"><code class="code">interface</code></span></dt><dd>
                сетевой интерфейс, на котором запущена очередь. Если
                интерфейс не определён, очередь будет работать на всех
                интерфейсах.
              </dd><dt><span class="term"><code class="code">bw</code></span></dt><dd>
                общая пропускная способность, доступная планировщику.
                Может содержать аббревиатуры b, Kb, Mb, Gb для
                обозначения bits, kilobits, megabits, и gigabits в
                секунду, конкретное значение или процент от общей
                пропускной способности. Указывается только при
                использовании планировщика cbq.
              </dd><dt><span class="term"><code class="code">pri</code></span></dt><dd>
                приоритет очереди. Для cbq приоритет изменяется от 0 до
                7, для priq диапазон от 0 до 15. Приоритет 0 считается
                самым низким. Если этот параметр не определён, ему
                назначается 1.
              </dd><dt><span class="term"><code class="code">qlim</code></span></dt><dd>
                максимальное число пакетов в очереди. Необязательный
                параметр. По умолчанию - 50.
              </dd><dt><span class="term"><code class="code">scheduler</code></span></dt><dd>
                используемый планировщик&nbsp;&#8212; cbq, priq или
                hfsc.  Должен быть таким же, как и родительская очередь.
              </dd><dt><span class="term"><code class="code">sched_options</code></span></dt><dd><p>
                  </p><p>
                    дополнительные опции для управления планировщиками:
                  </p><p>
                  </p><div class="variablelist"><dl><dt><span class="term"><code class="code">default</code></span></dt><dd>
                        очередь по умолчанию (может быть только одна).
                        Сюда будут включаться все пакеты, не подходящие
                        для остальных очередей.
                      </dd><dt><span class="term"><code class="code">red</code></span></dt><dd>
                        включить <span class="acronym">RED</span> для очереди.
                      </dd><dt><span class="term"><code class="code">rio</code></span></dt><dd>
                        включить <span class="acronym">RED</span> с
                        <span class="acronym">IN/OUT.</span> В этом режиме
                        <span class="acronym">RED</span> поддерживает очереди
                        различной длины и различные пороговые значения, по
                        одному на каждый уровень IP Quality of Service.
                      </dd><dt><span class="term"><code class="code">ecn</code></span></dt><dd>
                        Включить <span class="acronym">ECN</span> (работает
                        совместно с <span class="acronym">RED</span>).
                      </dd><dt><span class="term"><code class="code">borrow</code></span></dt><dd>
                        эта очередь может заимствовать пропускную
                        способность у других очередей. Может быть
                        определено только при использовании cbq.
                      </dd><dt><span class="term"><code class="code">queue_list</code></span></dt><dd>
                        список дочерних очередей. Может быть определено
                        только при использовании cbq.
                      </dd></dl></div><p>
                  </p><p>
                    Следующие три опции применяются только для очереди
                    типа <span class="acronym">HFSC</span>.
                  </p><p>
                  </p><div class="variablelist"><dl><dt><span class="term"><code class="code">realtime &lt;sc&gt;</code></span></dt><dd>
                        Минимальная полоса пропускания
                      </dd><dt><span class="term"><code class="code">upperlimit &lt;sc&gt;</code></span></dt><dd>
                        Максимальная полоса пропускания
                      </dd><dt><span class="term"><code class="code">linkshare &lt;sc&gt;</code></span></dt><dd>
                        Полоса, которую можно делить с другими очередями
                      </dd></dl></div><p>

                  </p><p>
                    Здесь <code class="code">&lt;sc&gt;</code> это
                    сокращение для service curve&nbsp;&#8212; кривая
                    сервиса. Кривая состоит из двух линейных участков и
                    описывается тремя числами (m1, d, m2).
                    m1&nbsp;&#8212; начальная полоса пропускания (т.е.
                    наклон первой кривой), d время в течении которого
                    действует первичная полоса пропускания в
                    миллисекундах и m2&nbsp;&#8212; наклон второго
                    линейного участка&nbsp;&#8212; т.е. реальная полоса
                    пропускания.
                  </p><p>

                  </p><p>
                    Столь детальное описание кривой сервиса позволяет
                    отдельно регулировать задержки при работе очереди и
                    полосу пропускания, тогда как в
                    <span class="acronym">CBQ</span> есть только регулировка
                    полосы пропускания и, следовательно, единственный
                    способ снизить задержки состоит в увеличении полосы
                    пропускания.
                  </p><p>
                </p></dd></dl></div><p>
            Продолжение примера:
          </p><div class="informalexample"><pre class="programlisting">queue std bandwidth 50% cbq(default)
queue ssh { ssh_login, ssh_bulk }
   queue ssh_login priority 4 cbq(ecn)
   queue ssh_bulk cbq(ecn)
queue ftp bandwidth 500Kb priority 3 cbq(borrow red)
            </pre></div><p>
            Здесь определяются дочерние очереди. Очереди std назначается
            50% пропускной способности от материнской очереди и она
            назначается дефолтной. Очередь ssh определяет две дочерние
            очереди, ssh_login и ssh_bulk. Ssh_login дают более высокий
            приоритет чем ssh_bulk, и обе работают с ECN. Ftp назначена
            полоса пропускания в 500&nbsp;kbps и дан приоритет 3. Эта
            очередь может арендовать свободную пропускную способность
            других очередей и используется red. 
          </p><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-queue-conf-traffic"></a>C.2.2.4.3.1. Назначение трафика очереди</h6></div></div></div><p>
              Для направления трафика в очередь используется ключевое
              слово queue в правилах пакетного фильтра. Для примера
              рассмотрим следующую строку: 
            </p><div class="informalexample"><pre class="programlisting">pass out on fxp0 from any to any port 22
              </pre></div><p>
              Пакеты из этого правила можно направить в очередь
              следующим способом:
            </p><div class="informalexample"><pre class="programlisting">pass out on fxp0 from any to any port 22 queue ssh
              </pre></div><p>
              Если ключевое слово <code class="code">queue</code>
              используется совместно с <code class="code">block</code>,
              все пакеты TCP RST или ICMP Unreachable ставятся в
              указанную очередь.
            </p><p>
              Обратите внимание, что <code class="code">queue</code>
              может приключиться для другого интерфейса, чем было
              определено директивой altq: 
            </p><div class="informalexample"><pre class="programlisting">altq on fxp0 cbq bandwidth 2Mb queue { std, ftp }
queue std cbq(default)
queue ftp bandwidth 1.5Mb

pass in on dc0 from any to any port 21 queue ftp
              </pre></div><p>
              Очередь определяется на fxp0, но указание на неё
              встречается на dc0. Если пакет, соответствующий правилу
              выходит с интерфейса fxp0, то он будет поставлен в очередь
              ftp. Этот тип очередей может быть очень полезен на
              маршрутизаторах.
            </p><p>
              Обычно с ключевым словом <code class="code">queue</code>
              используется только одно имя очереди, но если определено и
              второе имя, то очередь будет использоваться для пакетов с
              Type of Service (ToS) низкой задержки и для пакетов TCP ACK
              без полезного груза данных. Хороший пример может быть
              найден при использовании ssh: во время открытия сессии ToS
              устанавливается в low-delay пока не откроется сессия SCP
              или SFTP. PF может использовать информацию о находящихся в
              очереди пакетах для того. чтобы отличить пакеты на ввод
              логина от остальных пакетов. Возможно будет полезным
              разнести по приоритетам пакеты авторизации от пакетов
              данных: 
            </p><div class="informalexample"><pre class="programlisting">pass out on fxp0 from any to any port 22 queue(ssh_bulk, ssh_login)
              </pre></div><p>
              Повышение приоритета пакетов TCP ACK имеет смысл на
              асинхронных соединениях, таких как ADSL, где скорость
              входящего и исходящего потока не равны между собой. На
              ADSL линии при полностью занятом исходящем канале будет
              снижаться и полезное использование входящего канала, так
              как пакеты TCP ACK будут теряться и задерживаться.
              Тестирования показали, что для достижения наибольшей
              эффективности, полоса пропускания должна быть немного
              меньше, возможностей канала. Например, если ADSL
              линия дает максимальную скорость в 640&nbsp;kbps,
              установите значение пропускной способности для корневой
              линии в 600&nbsp;kb. Оптимальное значение находится путем
              проб и ошибок. 
            </p><p>
              Когда ключевое слово <code class="code">queue</code>
              используется с правилами <code class="code">keep
                state</code>, пакетный фильтр будет делать запись
              очереди в таблице состояний таким образом, что пакеты с
              fxp0 соответствующие образовавшемуся соединению будут
              оказываться в очереди ssh:
            </p><div class="informalexample"><pre class="programlisting">pass in on fxp0 proto tcp from any to any port 22 flags S/SA \
   keep state queue ssh
              </pre></div><p>
              Обратите внимание, что ключевое слово <code class="code">queue</code> применяется к правилам,
              обслуживающим входящий трафик.
            </p></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-queue-ex1"></a>C.2.2.4.4. Пример 1: небольшая домашняя сеть</h5></div></div></div><div class="informalexample"><pre class="programlisting">    [ Alice ]    [ Charlie ]
        |             |                              ADSL
     ---+-----+-------+------ dc0 [ OpenBSD ] fxp0 -------- ( Internet )
              |
           [ Bob ]
            </pre></div><p>
            В этом примере <span class="acronym">OpenBSD</span> используется как
            шлюз в Интернет для маленькой домашней сети с тремя рабочими
            станциями. На шлюзе работает NAT и фильтрация пакетов. Выход
            в Интернет осуществляется по ADSL с входящей скоростью 2Mbps
            и исходящей 640Kbps. 
          </p><p>
            Для очередей действуют следующие правила: 
          </p><div class="itemizedlist"><ul type="disc"><li>
              Выделяем 80Kbps для игр Боба, чтобы не стонал, когда Алиса
              и Чарли качают фильмы и музыку. Когда есть свободная
              полоса&nbsp;&#8212; пусть берёт.
            </li><li>
              SSH трафик и трафик интернет-пейджеров имеет высший
              приоритет.
            </li><li>
              DNS запросы-ответы имеют приоритет чуть ниже.
            </li><li>
              Исходящие TCP ACK имеют высший приоритет по сравнению со
              всем остальным исходящим трафиком.
            </li></ul></div><p>
            Ниже представлены правила, реализующие эту политику.
            Обратите внимание, что в <code class="filename">pf.conf</code> не
            представлены правила nat, rdr, options, и т.д.
            непосредственно не имеющие отношения к данной задаче.
          </p><div class="informalexample"><pre class="programlisting"># Включаем очереди на внешнем интерфейсе для контроля за трафиком
# выходящим в Интернет. Используем планировщик priq для контроля только
# по приоритетам. Устанавливает ширину пропускания 610 kbps для
# оптимального пропускания очереди TCP ACK

altq on fxp0 priq bandwidth 610Kb queue { std_out, ssh_im_out, dns_out, \
    tcp_ack_out }

# определяем параметры дочерних очередей
# std_out      - стандартная очередь. Любые правила ниже, в которых
#                очередь не указана явно, добавляют трафик к этой
#                очереди.
# ssh_im_out   - интерактивный SSH и интернет пейджеры
# dns_out      - запросы DNS
# tcp_ack_out  - пакеты TCP ACK не несущие полезной нагрузки

queue std_out     priq(default)
queue ssh_im_out  priority 4 priq(red)
queue dns_out     priority 5
queue tcp_ack_out priority 6

# Включаем очереди на внутреннем интерфейсе для контроля трафика
# пришедшего из Интернет. Используем планировщик cbq для контроля полосы
# пропускания. Максимальная полоса 2 Mbps.

altq on dc0 cbq bandwidth 2Mb queue { std_in, ssh_im_in, dns_in, bob_in }

# определяем параметры дочерних очередей
# std_in       - стандартная очередь. Любые правила ниже, в которых
#                очередь не указана явно, добавляют трафик к этой
#                очереди.
# ssh_im_in    - интерактивный SSH и интернет пейджеры
# dns_in       - ответы DNS
# bob_in       - Полоса зарезервированная для Боба, разрешаем ему
#                увеличивать полосу по мере возможности (borrow)

queue std_in    bandwidth 1.6Mb cbq(default)
queue ssh_im_in bandwidth 200Kb priority 4
queue dns_in    bandwidth 120Kb priority 5
queue bob_in    bandwidth 80Kb cbq(borrow)


# ... раздел фильтрации ...

alice         = "192.168.0.2"
bob           = "192.168.0.3"
charlie       = "192.168.0.4"
local_net     = "192.168.0.0/24"
ssh_ports     = "{ 22 2022 }"
im_ports      = "{ 1863 5190 5222 }"

# правила фильтрации входящего трафика на fxp0
block in on fxp0 all

# правила фильтрации исходящего трафика на fxp0
block out on fxp0 all
pass  out on fxp0 inet proto tcp from (fxp0) to any flags S/SA \
    keep state queue(std_out, tcp_ack_out)
pass  out on fxp0 inet proto { udp icmp } from (fxp0) to any keep state
pass  out on fxp0 inet proto { tcp udp } from (fxp0) to any port domain \
    keep state queue dns_out
pass  out on fxp0 inet proto tcp from (fxp0) to any port $ssh_ports \
    flags S/SA keep state queue(std_out, ssh_im_out)
pass  out on fxp0 inet proto tcp from (fxp0) to any port $im_ports \
    flags S/SA keep state queue(ssh_im_out, tcp_ack_out)

# правила фильтрации входящего трафика на dc0
block in on dc0 all
pass  in on dc0 from $local_net

# правила фильтрации исходящего трафика на dc0
block out on dc0 all
pass  out on dc0 from any to $local_net
pass  out on dc0 proto { tcp udp } from any port domain to $local_net \
    queue dns_in
pass  out on dc0 proto tcp from any port $ssh_ports to $local_net \
    queue(std_in, ssh_im_in)
pass  out on dc0 proto tcp from any port $im_ports to $local_net \
    queue ssh_im_in
pass  out on dc0 from any to $bob queue bob_in
            </pre></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-queue-ex2"></a>C.2.2.4.5. Пример 2: корпоративная сеть</h5></div></div></div><div class="informalexample"><pre class="programlisting">  ( IT Dept )  [ Boss's PC ]
       |          |                                   T1
     --+----+-----+---------- dc0 [ OpenBSD ] fxp0 -------- ( Internet )
            |                         fxp1
         [ COMP1 ]    [ WWW ]         /
                         |           /
                       --+----------'
            </pre></div><p>
            В этом примере <span class="acronym">OpenBSD</span> выступает в роли
            системы сетевой защиты для корпоративной сети. В компании
            работает WWW сервер, установленный в DMZ. Клиенты обновляют
            свои сайты через FTP.  У IT одела имеется собственная
            подсеть, соединённая с главной, босс использует свой
            компьютер для почты и серфинга по сети. Соединение с
            Интернетом осуществляется на скорости T1 (1.5&nbsp;Mbps) в
            обе стороны. Все прочие сетевые сегменты используют Fast
            Ethernet (100&nbsp;Mbps). 
          </p><p>
            Сетевой администратор выбрал следующую политику: 
          </p><div class="itemizedlist"><ul type="disc"><li><p>
                Трафик между WWW сервером и Интернетом ограничивается
                500&nbsp;kbps:
              </p><div class="itemizedlist"><ul type="circle"><li>
                  Выделяем 250&nbsp;kbps на HTTP трафик
                </li><li>
                  Выделяем 250&nbsp;kbps на не-HTTP трафик
                </li><li>
                  Обеим очередям позволяем расти до полной полосы в
                  500&nbsp;kbps
                </li><li>
                  HTTP трафику между WWW сервером и Интернет дать
                  больший приоритет, чем не-HTTP (к примеру ftp-закачка).
                </li></ul></div></li><li>
              Трафик между внутренней сетью и WWW сервером может
              использовать всю полосу 100&nbsp;Mbps, которую позволяет
              сеть.
            </li><li>
              500&nbsp;kbps резервируется для IT для того, чтобы качать
              последние версии программного обеспечения. IT может
              забрать большую полосу, если есть такая возможность.
            </li><li>
              Трафик между начальником и Интернетом имеет высший
              приоритет по сравнению со всем.
            </li></ul></div><p>
            Ниже представлены правила, реализующие эту политику.
            Обратите внимание, что в <code class="filename">pf.conf</code> не
            представлены правила nat, rdr, options, и т.д.
            непосредственно не имеющие отношения к данной задаче.
          </p><div class="informalexample"><pre class="programlisting"># Включаем очереди на внешнем интерфейсе для пакетов выходящих в
# Интернет. Используем планировщик cbq чтобы контролировать полосу
# пропускания каждой очереди. Максимальная исходящая полоса 1.5 Mbps

altq on fxp0 cbq bandwidth 1.5Mb queue { std_ext, www_ext, boss_ext }

# определяем параметры дочерних очередей
# std_ext        - стандартная очередь. Так же является очередью для
#                  исходящего трафика на интерфейсе fxp0
# www_ext        - контейнер для очередей WWW сервера. Размер 500 kbps
#   www_ext_http - http трафик WWW сервера - высший приоритет
#   www_ext_misc - не-http трафик WWW сервера
# boss_ext       - трафик пришедший с компьютера босса

queue std_ext        bandwidth 500Kb cbq(default borrow)
queue www_ext        bandwidth 500Kb { www_ext_http, www_ext_misc }
  queue www_ext_http bandwidth 50% priority 3 cbq(red borrow)
  queue www_ext_misc bandwidth 50% priority 1 cbq(borrow)
queue boss_ext       bandwidth 500Kb priority 3 cbq(borrow)

# Включить очереди на внутреннем интерфейсе для контроля трафика
# входящего из интернета или из DMZ. Используем планировщик cbq для
# контроля за каждой очередью. Полоса пропускания устанавливается в
# максимум. Трафику из DMZ позволяется использовать всю полосу, а
# трафику пришедшему из Интернет рарешается использовать 1.0 Mbps
# (поскольку 0.5 Mbps (500 kbps) зарезервировано на fxp1).

altq on dc0 cbq bandwidth 100% queue { net_int, www_int }

# определяем параметры дочерних очередей
# net_int    - Контейнер для трафика из Интернет. Полоса 1.0 Mbps
#   std_int  - Стандартная очередь. Так же является оередью по умолчанию
#              для исходящего трафика на dc0
#   it_int   - Трафик IT-отдела. Им зарезервировано 500 kbps
#   boss_int - Трафик босса имеет высший приоритет
# www_int    - Трафик WWW сервера из DMZ не имеет ограничений

queue net_int    bandwidth 1.0Mb { std_int, it_int, boss_int }
  queue std_int  bandwidth 250Kb cbq(default borrow)
  queue it_int   bandwidth 500Kb cbq(borrow)
  queue boss_int bandwidth 250Kb priority 3 cbq(borrow)
queue www_int    bandwidth 99Mb cbq(red borrow)

# Включаем очереди на интерфейсе DMZ для контроля трафика идущего к WWW
# серверу. Используем планировщик cbq для контроля за полосой
# пропускания. Полоса выставляется в максимум. Трафик из внутренней сети
# может использовать всю полосу пропускания, а трафик из Интернет
# ограничен 500 kbps.

altq on fxp1 cbq bandwidth 100% queue { internal_dmz, net_dmz }

# определяем параметры дочерних очередей
# internal_dmz   - трафик из внутренней сети
# net_dmz        - контейнер для очередей трафика идущего из Интернет
#   net_dmz_http - http трафик, наивысший приоритет
#   net_dmz_misc - не-http трафик. Это очередь по умолчанию

queue internal_dmz   bandwidth 99Mb cbq(borrow)
queue net_dmz        bandwidth 500Kb { net_dmz_http, net_dmz_misc }
  queue net_dmz_http bandwidth 50% priority 3 cbq(red borrow)
  queue net_dmz_misc bandwidth 50% priority 1 cbq(default borrow)


# ... раздел фильтрации ...

main_net  = "192.168.0.0/24"
it_net    = "192.168.1.0/24"
int_nets  = "{ 192.168.0.0/24, 192.168.1.0/24 }"
dmz_net   = "10.0.0.0/24"

boss      = "192.168.0.200"
wwwserv   = "10.0.0.100"

# default deny
block on { fxp0, fxp1, dc0 } all

# правила фильтрации входящего трафика на интерфейсе fxp0
pass in on fxp0 proto tcp from any to $wwwserv port { 21, \
    &gt; 49151 } flags S/SA keep state queue www_ext_misc
pass in on fxp0 proto tcp from any to $wwwserv port 80 \
    flags S/SA keep state queue www_ext_http

# правила фильтрации исходящего трафика на интерфейсе fxp0
pass out on fxp0 from $int_nets to any keep state
pass out on fxp0 from $boss to any keep state queue boss_ext

# правила фильтрации входящего трафика на интерфейсе dc0
pass in on dc0 from $int_nets to any keep state
pass in on dc0 from $it_net to any queue it_int
pass in on dc0 from $boss to any queue boss_int
pass in on dc0 proto tcp from $int_nets to $wwwserv port { 21, 80, \
    &gt; 49151 } flags S/SA keep state queue www_int

# правила фильтрации исходящего трафика на интерфейсе dc0
pass out on dc0 from dc0 to $int_nets

# правила фильтрации входящего трафика на интерфейсе fxp1
pass in on fxp1 proto { tcp, udp } from $wwwserv to any port 53 \
    keep state

# правила фильтрации исходящего трафика на интерфейсе fxp1
pass out on fxp1 proto tcp from any to $wwwserv port { 21, \
    &gt; 49151 } flags S/SA keep state queue net_dmz_misc
pass out on fxp1 proto tcp from any to $wwwserv port 80 \
    flags S/SA keep state queue net_dmz_http
pass out on fxp1 proto tcp from $int_nets to $wwwserv port { 80, \
    21, &gt; 49151 } flags S/SA keep state queue internal_dmz
            </pre></div></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-pools"></a>C.2.2.5. Адресные пулы, балансировка нагрузки</h4></div></div></div><p>
          Адресным пулом называется адресное пространство более чем из
          двух адресов, используемое группой пользователей. Адресный пул
          может быть указан в правилах перенаправления, трансляции и
          указан как адрес назначения в опциях фильтрации <code class="code">route-to</code>, <code class="code">reply-to</code> и <code class="code">dup-to</code>. 
        </p><p>
          Существует четыре способа использования адресных пулов:
        </p><div class="variablelist"><dl><dt><span class="term"><code class="code">bitmask</code></span></dt><dd>
              назначение адреса из пула согласно исходному сетевому адресу
              (адрес источника для правил nat, адрес назначения для
              правил rdr). Пример: если пул адресов включает
              192.0.2.1/24 и модифицируемый адрес 10.0.0.50, то
              результирующим адресом будет 192.0.2.50. Если пул адресов
              включает 192.0.2.1/25 и модифицируемый адрес 10.0.0.130,
              результатом будет 192.0.2.2.
            </dd><dt><span class="term"><code class="code">random</code></span></dt><dd>
              случайный выбор адресов из пула
            </dd><dt><span class="term"><code class="code">source-hash</code></span></dt><dd>
              использование хэша адреса источника для распределения
              адресов из пула. Этот метод гарантирует соответствие
              адреса источника и адреса, взятого из пула. Ключ для
              алгоритма хеширования может быть определён дополнительно
              после ключевого слова <code class="code">source-hash</code> в шестнадцатеричном
              формате или как строка. По умолчанию,
              <span><strong class="command">pfctl(8)</strong></span> генерирует случайный ключ при
              каждой загрузке набора правил.
            </dd><dt><span class="term"><code class="code">round-robin</code></span></dt><dd>
              использование адресов пула по кругу. Это метод по
              умолчанию и единственный метод, когда пул адресов
              определён из таблицы.
            </dd></dl></div><p>
          За исключением метода <code class="code">round-robin</code>,
          пул адресов должен быть определён как блок адресов
          <span class="acronym">CIDR</span>. В методе <code class="code">round-robin</code> используется назначение
          адресов из таблицы. 
        </p><p>
          Опция <code class="code">sticky-address</code> (дословно
          &#171;липкий адрес&#187;) может использоваться с пулами <code class="code">random</code> и <code class="code">round-robin</code> для гарантии назаначения
          всегда одного и того же адреса источника в адрес пула. 
        </p><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pools-nat"></a>C.2.2.5.1. Адресные пулы NAT</h5></div></div></div><p>
            Пул адресов можно использовать для трансляции адресов в
            правилах nat. Адрес источника транслируется не в отдельный
            адрес, а в адрес взятый при помощи одного из перечисленных
            выше методов из пула.  Это может оказаться очень полезным в
            случае. когда пакетный фильтр транслирует адреса для очень
            большой сети.  Так как число одновременных NAT соединений на
            один внешний адрес ограниченно, выделение для этих целей
            пула адресов позволит значительно увеличить число
            пользователей. 
          </p><p>
            В следующем примере пул из двух адресов используется для
            трансляции исходящих пакетов. Для каждого исходящего
            соединения пакетный фильтр производит ротацию адресов
            методом round-robin: 
          </p><div class="informalexample"><pre class="programlisting">nat on $ext_if inet from any to any -&gt; { 192.0.2.5, 192.0.2.10 }
            </pre></div><p>
            Существенным недостатком этого метода будет то, что не
            всегда будет соблюдаться соответствие между исходным адресом
            и адресом трансляции. Это может вызвать проблему при заходе
            на web-узлы: они не смогут корректно обрабатывать информацию
            о сессиях. Решением этой проблемы может стать использование
            метода source-hash для привязки внутреннего адреса к адресу
            трансляции. В этом случае адресный пул должен быть определён
            как сетевой блок CIDR: 
          </p><div class="informalexample"><pre class="programlisting">nat on $ext_if inet from any to any -&gt; 192.0.2.4/31 source-hash
            </pre></div><p>
            В этом правиле nat используется пул адресов 192.0.2.4/31
            (192.0.2.4&nbsp;&#8212; 192.0.2.5) как адреса трансляции
            для исходящих пакетов. Каждый внутренний адрес будет всегда
            транслироваться в свой внешний адрес, так как указано
            ключевое слово <code class="code">source-hash</code>. 
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pools-balance-in"></a>C.2.2.5.2. Балансировка нагрузки входящего трафика</h5></div></div></div><p>
            Пулы адресов также могут использоваться для балансировки
            нагрузки входящих подключений. Для примера, входящие
            подключения на web-сервер могут быть распределены между
            серверной фермой: 
          </p><div class="informalexample"><pre class="programlisting">web_servers = "{ 10.0.0.10, 10.0.0.11, 10.0.0.13 }"

rdr on $ext_if proto tcp from any to any port 80 -&gt; $web_servers \
   round-robin sticky-address
            </pre></div><p>
            Все соединения циклически будут перенаправляться на серверы
            фермы используя метод round-robin. При этом пакеты
            принадлежащие одному соединению будут направляться одному
            серверу ("sticky connection"), но следующее соединение
            открытое этим же хостом, будет направлено следующему
            серверу.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pools-balance-out"></a>C.2.2.5.3. Балансировка нагрузки исходящего трафика</h5></div></div></div><p>
            Пулы адресов могут использоваться для балансировки нагрузки
            между двумя и более внешними каналами с использованием опции
            route-to в случае невозможности организовать динамическую
            маршрутизацию (например, с использованием протокола BGP4).
            Совместное использование <code class="code">route-to</code>
            и пула адресов <code class="code">round-robin</code>
            позволяет распределить исходящие соединения между разными
            провайдерами. 
          </p><p>
            В качестве дополнительной информации необходимо указать
            адреса маршрутизаторов для каждого Интернет-соединения. Это
            нужно для опции <code class="code">route-to</code>, дабы
            управлять исходящими пакетами. 
          </p><p>
            Следующий пример иллюстрирует балансировку нагрузки между
            двумя каналами: 
          </p><div class="informalexample"><pre class="programlisting">lan_net = "192.168.0.0/24"
int_if  = "dc0"
ext_if1 = "fxp0"
ext_if2 = "fxp1"
ext_gw1 = "68.146.224.1"
ext_gw2 = "142.59.76.1"

pass in on $int_if route-to \
   { ($ext_if1 $ext_gw1), ($ext_if2 $ext_gw2) } round-robin \
   from $lan_net to any keep state 
            </pre></div><p>
            Опция <code class="code">route-to</code> используется для
            приёма трафика на внутреннем интерфейсе и назначения ему
            внешнего сетевого интерфейса и шлюза, таким образом
            обеспечивая балансировку. Обратите внимание, что опция
            <code class="code">route-to</code> должна быть указана в
            каждом правиле, предназначенном для балансировки трафика.
            Ответные пакеты приходят на тот интерфейс, с которого ушёл
            запрос и они будут перенаправлены во внутрь как обычно. 
          </p><p>
            Для гарантии того, что пакеты с $ext_if1 всегда направляются
            к $ext_gw1 (и соответственно для $ext_if2 к $ext_gw2), в
            правилах можно указать следующее: 
          </p><div class="informalexample"><pre class="programlisting">pass out on $ext_if1 route-to ($ext_if2 $ext_gw2) from $ext_if2 to any
pass out on $ext_if2 route-to ($ext_if1 $ext_gw1) from $ext_if1 to any
            </pre></div><p>
            NAT можно использовать на каждом внешнем интерфейсе:
          </p><div class="informalexample"><pre class="programlisting">nat on $ext_if1 from $lan_net to any -&gt; ($ext_if1)
nat on $ext_if2 from $lan_net to any -&gt; ($ext_if2)
            </pre></div><p>
            Ниже дан полный пример правил для балансировки внешнего
            трафика:
          </p><div class="informalexample"><pre class="programlisting">lan_net = "192.168.0.0/24"
int_if  = "dc0"
ext_if1 = "fxp0"
ext_if2 = "fxp1"
ext_gw1 = "68.146.224.1"
ext_gw2 = "142.59.76.1"

#  правила nat для исходящих соединений на каждом внешнем интерфейсе
nat on $ext_if1 from $lan_net to any -&gt; ($ext_if1)
nat on $ext_if2 from $lan_net to any -&gt; ($ext_if2)

#  default deny
block in  from any to any
block out from any to any

#  пропускаем все исходящие пакеты на внутреннем итерфейсе
pass out on $int_if from any to $lan_net
#  пропускаем (quick) пакеты предназначенные самому шлюзу
pass in quick on $int_if from $lan_net to $int_if
#  балансировка исходящего tcp трафика идущего из внутренней сети
pass in on $int_if route-to \
    { ($ext_if1 $ext_gw1), ($ext_if2 $ext_gw2) } round-robin \
    proto tcp from $lan_net to any flags S/SA modulate state
#  балансировка исходящего icmp и udp трафика идущего из внутренней сети
pass in on $int_if route-to \
    { ($ext_if1 $ext_gw1), ($ext_if2 $ext_gw2) } round-robin \
    proto { udp, icmp } from $lan_net to any keep state

#  основные "выпускаюшие" правила на внешнем интерфейсе
pass out on $ext_if1 proto tcp from any to any flags S/SA modulate state
pass out on $ext_if1 proto { udp, icmp } from any to any keep state
pass out on $ext_if2 proto tcp from any to any flags S/SA modulate state
pass out on $ext_if2 proto { udp, icmp } from any to any keep state

#  маршрутизация пакетов идущих с любого IP на $ext_if1 через $ext_gw1 и
#  пакетов идущих  на $ext_if2 через $ext_gw2
pass out on $ext_if1 route-to ($ext_if2 $ext_gw2) from $ext_if2 to any 
pass out on $ext_if2 route-to ($ext_if1 $ext_gw1) from $ext_if1 to any 
            </pre></div></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-tagging"></a>C.2.2.6. Маркирование пакетов, фильтрация на основе политик</h4></div></div></div><p>
          Маркирование пакетов&nbsp;&#8212; способ пометить пакет
          внутренним идентификатором для дальнейшего использования в
          качестве критерия в правилах трансляции и фильтрации.
          Маркирование позволяет создать &#171;доверие&#187; между
          интерфейсами, а так же помогает оределить был ли пакет
          обработан правилами трансляции.  Также становится возможным
          переход от фильтрации, основанной на правилах, к фильтрации,
          основанной на политиках. 
        </p><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-tagging-assign"></a>C.2.2.6.1. Присваивание маркера пакетам</h5></div></div></div><p>
            Для присвоения маркера используется ключевое слово <code class="code">tag</code>:
          </p><div class="informalexample"><pre class="programlisting">pass in on $int_if all tag INTERNAL_NET keep state
            </pre></div><p>
            Маркер <code class="code">INTERNAL_NET</code> будет присвоен
            любому пакету соответствующему правилу.
          </p><p>
            Маркер может быть присвоен с использованием <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-macro" title="C.2.1.2. Макросы">макросов</a>, например:
          </p><div class="informalexample"><pre class="programlisting">name = "INTERNAL_NET"
pass in on $int_if all tag $name keep state
            </pre></div><p>
            Существует набор предопределённых макросов, которые можно
            использовать для этих целей:
          </p><div class="variablelist"><dl><dt><span class="term"><code class="code">$if</code></span></dt><dd>
                интерфейс
              </dd><dt><span class="term"><code class="code">$srcaddr</code></span></dt><dd>
                IP адрес источника
              </dd><dt><span class="term"><code class="code">$dstaddr</code></span></dt><dd>
                IP адрес назначения
              </dd><dt><span class="term"><code class="code">$srcport</code></span></dt><dd>
                порт источника
              </dd><dt><span class="term"><code class="code">$dstport</code></span></dt><dd>
                порт назначения
              </dd><dt><span class="term"><code class="code">$proto</code></span></dt><dd>
                протокол
              </dd><dt><span class="term"><code class="code">$nr</code></span></dt><dd>
                номер правила
              </dd></dl></div><p>
            Эти макросы определяются во время загрузки, а не во время
            работы. 
          </p><p>
            Маркирование подчиняется следующим правилам:
          </p><div class="itemizedlist"><ul type="disc"><li>
              Маркер &#171;приклеивается&#187;. Однажды приклеившись к
              пакету, маркер не может быть удалён, однако его можно
              заменить другим маркером.
            </li><li>
              Поскольку маркеры &#171;клейкие&#187; пакет может иметь
              маркер даже если последнее правило не содержит ключевое
              слово <code class="code">tag</code>.
            </li><li>
              Одному пакету можно назначить только один маркер.
            </li><li>
              Маркеры это <span class="emphasis"><em>внутренние</em></span>
              идентификаторы, они не посылаются по сети.
            </li><li>
              Длина маркера раньше составляла 15 символов, начиная с
              <span class="acronym">OpenBSD</span> 4.0 до 63 символов.
            </li></ul></div><p>
            Рассмотрим следующий пример:
          </p><div class="informalexample"><pre class="programlisting">pass in on $int_if tag INT_NET keep state <a name="pf-tags-ex1-area" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-tags-ex1-co"><img src="pf_02_files/1.png" alt="1" border="0"></a>
pass in quick on $int_if proto tcp to port 80 tag INT_NET_HTTP keep state <a name="pf-tags-ex2-area" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-tags-ex2-co"><img src="pf_02_files/2.png" alt="2" border="0"></a>
pass in quick on $int_if from 192.168.1.5 keep state <a name="pf-tags-ex3-area" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-tags-ex3-co"><img src="pf_02_files/3.png" alt="3" border="0"></a>
            </pre></div><div class="calloutlist"><table summary="Callout list" border="0"><tbody><tr><td valign="top" width="5%" align="left"><a name="pf-tags-ex1-co"></a><a href="#pf-tags-ex1-area"><img src="pf_02_files/1.png" alt="1" border="0"></a> </td><td valign="top" align="left">
                Пакеты вошедшие через интерфейс <code class="code">$int_if</code> будут помечены маркером
                INT_NET
              </td></tr><tr><td valign="top" width="5%" align="left"><a name="pf-tags-ex2-co"></a><a href="#pf-tags-ex2-area"><img src="pf_02_files/2.png" alt="2" border="0"></a> </td><td valign="top" align="left">
                Пакеты пришедшие через интерфейс <code class="code">$int_if</code>, направляющиеся на порт
                80, были помечены как INT_NET, но здесь меняют маркер на
                INT_NET_HTTP
              </td></tr><tr><td valign="top" width="5%" align="left"><a name="pf-tags-ex3-co"></a><a href="#pf-tags-ex3-area"><img src="pf_02_files/3.png" alt="3" border="0"></a> </td><td valign="top" align="left">
                Пакет идущий на адрес 192.168.1.5 будет помечен либо
                маркером INT_NET_HTTP (если он идёт на порт 80), либо
                INT_NET. Хотя в пследнем правиле ключевого слова <code class="code">tag</code> нет. Это и есть
                &#171;клейкость&#187; маркера.
              </td></tr></tbody></table></div><p>
            В правилах nat, rdr и binat тоже можно метить пакеты при
            помощи ключевого слова <code class="code">tag</code>.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-tagging-check"></a>C.2.2.6.2. Проверка маркеров</h5></div></div></div><p>
            Для проверки установленных маркеров используется ключевое
            слово <code class="code">tagged</code>:
          </p><div class="informalexample"><pre class="programlisting">pass out on $ext_if tagged INT_NET keep state
            </pre></div><p>
            Это правило соответствует исходящим пакетам на интерфейсе
            <code class="code">$ext_if</code> помеченным маркером
            INT_NET. Восклицательный знак используется для
            инвертирования правила:
          </p><div class="informalexample"><pre class="programlisting">pass out on $ext_if ! tagged WIFI_NET keep state
            </pre></div><p>
            В правилах nat, rdr и binat так же допускается использование
            ключевого слова <code class="code">tagged</code>.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-tagging-policy"></a>C.2.2.6.3. Фильтрация на основе политик</h5></div></div></div><p>
            Фильтрация пакетов на основе политик несколько отличается от
            фильтрации на основе правил. В политиках устанавливаются
            правила, по которым некоторый вид трафика должен быть
            пропущен, а некоторый запрещён. Пакеты классифицируются
            внутри политик на основе традиционных
            критериев&nbsp;&#8212; IP адреса источника/назначения,
            протокола и т.д. Рассмотрим следующий пример:
          </p><div class="itemizedlist"><ul type="disc"><li>
              Трафик из внутренней сети LAN в Интернет пропускается
              (LAN_INET) и должен быть транслирован (LAN_INET_NAT)
            </li><li>
              Разрешается трафик из внутренней сети LAN в DMZ (LAN_DMZ)
            </li><li>
              Разрешается трафик из Интернета в DMZ (INET_DMZ)
            </li><li>
              Разрешается трафик, который должен быть завёрнут демону
              <span><strong class="command">spamd(8)</strong></span> (SPAMD)
            </li><li>
              Весь остальной трафик блокируется.
            </li></ul></div><p>
            Заметьте, что политики охватывают <span class="emphasis"><em>весь</em></span>
            трафик идущий через брандмауэр. В круглых скобках указаны
            маркеры используемые для данной политики.
          </p><p>
            Правила фильтрации и трансляции:
          </p><div class="informalexample"><pre class="programlisting">rdr on $ext_if proto tcp from &lt;spamd&gt; to port smtp \
   tag SPAMD -&gt; 127.0.0.1 port 8025
nat on $ext_if tag LAN_INET_NAT tagged LAN_INET -&gt; ($ext_if)

block all
pass in on $int_if from $int_net tag LAN_INET keep state
pass in on $int_if from $int_net to $dmz_net tag LAN_DMZ keep state
pass in on $ext_if proto tcp to $www_server port 80 tag INET_DMZ keep state
            </pre></div><p>
            Таким образом, мы установили какой трафик соответствует какой
            политике. Теперь разрешим проход трафика принадлежащего
            политикам SPAMD, LAN_INET_NAT, LAN_DMZ и INET_DMZ:
          </p><div class="informalexample"><pre class="programlisting">pass in  quick on $ext_if tagged SPAMD keep state
pass out quick on $ext_if tagged LAN_INET_NAT keep state
pass out quick on $dmz_if tagged LAN_DMZ keep state
pass out quick on $dmz_if tagged INET_DMZ keep state
            </pre></div><p>
            Теперь все политики определены. Если мы захотим добавить
            POP3/SMTP сервер в DMZ, нам надо будет добавить следующие
            строки в <code class="filename">pf.conf(5)</code>:
          </p><div class="informalexample"><pre class="programlisting">mail_server = "192.168.0.10"
...
pass in on $ext_if proto tcp to $mail_server port { smtp, pop3 } \
   tag INET_DMZ keep state
            </pre></div><p>
            Таким образом, трафик электронной почты будет
            соответствовать политике INET_DMZ и будет пропущен.
          </p><p>
            Полный набор правил:
          </p><div class="informalexample"><pre class="programlisting"># macros
int_if  = "dc0"
dmz_if  = "dc1"
ext_if  = "ep0"
int_net = "10.0.0.0/24"
dmz_net = "192.168.0.0/24"
www_server = "192.168.0.5"
mail_server = "192.168.0.10"

table &lt;spamd&gt; persist file "/etc/spammers"

# классификация пакетов основанная на определённых в брандмауэре
# политиках
rdr on $ext_if proto tcp from &lt;spamd&gt; to port smtp \
    tag SPAMD -&gt; 127.0.0.1 port 8025
nat on $ext_if tag LAN_INET_NAT tagged LAN_INET -&gt; ($ext_if)

block all
pass in on $int_if from $int_net tag LAN_INET keep state
pass in on $int_if from $int_net to $dmz_net tag LAN_DMZ keep state
pass in on $ext_if proto tcp to $www_server port 80 tag INET_DMZ keep state 
pass in on $ext_if proto tcp to $mail_server port { smtp, pop3 } \
    tag INET_DMZ keep state 

# применение политик -- фильтрация на основе опрелелённых в брандмауэре
# политиках
pass in  quick on $ext_if tagged SPAMD keep state
pass out quick on $ext_if tagged LAN_INET_NAT keep state
pass out quick on $dmz_if tagged LAN_DMZ keep state
pass out quick on $dmz_if tagged INET_DMZ keep state
            </pre></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-tagging-ethernet"></a>C.2.2.6.4. Маркирование кадров ethernet (канальный уровень OSI)</h5></div></div></div><p>
            Если машина работает как мост на канальном уровне (в
            <span class="acronym">OpenBSD</span> см. <span><strong class="command">bridge(4)</strong></span>
            в <span class="acronym">FreeBSD</span>
            <span><strong class="command">if_bridge(4)</strong></span>) пакетный фильтр может
            маркировать кадры ethernet. При создании правил трансляции
            при помощи команды <span><strong class="command">brconfig(8)</strong></span>
            (характерна для <span class="acronym">OpenBSD</span>) можно установить
            маркер с помощью опции <code class="code">tag</code>:
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> brconfig bridge0 rule pass in on fxp0 src 0:de:ad:be:ef:0 tag USER1
            </pre></div><p>
            Далее можно ссылаться на этот маркер в
            <code class="filename">pf.conf(5)</code>:
          </p><div class="informalexample"><pre class="programlisting">pass in on fxp0 tagged USER1
            </pre></div></div></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h3 class="title"><a name="pf-addons"></a>C.2.3. Дополнительные разделы</h3></div></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-pflog"></a>C.2.3.1. Журналирование в пакетном фильтре</h4></div></div></div><p>
          Журналирование в пакетном фильтре осуществляется при помощи
          демона <span><strong class="command">pflogd(8)</strong></span> слушающего сетевой
          интерфейс <code class="code">pflog0</code> и записывающего
          пакеты в журнальный файл <code class="filename">/var/log/pflog</code> в
          бинарном формате libpcap, который можно просматривать при
          помощи программы <span><strong class="command">tcpdump(1)</strong></span> или
          <span><strong class="command">wireshark(1)</strong></span>, она же
          <span><strong class="command">ethereal(1)</strong></span> (см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/ch06s11.html" title="6.11. Демонстрация основных навыков работы с утилитой
      tcpdump(1)">Раздел&nbsp;6.11, &#171;Демонстрация основных навыков работы с утилитой
      <span><strong class="command">tcpdump(1)</strong></span>&#187;</a>).
          У программы <span><strong class="command">tcpdump(1)</strong></span> есть специальные
          <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/ch06s11.html#3.6.11-pflog">правила для работы с пакетным
            фильтром</a>. Кроме того, программа
          <span><strong class="command">tcpdump(1)</strong></span> позволяет просматривать журнал
          &#171;на лету&#187; если запустить её на прослушивание
          интерфейса <code class="code">pflog0</code>.  Для помещения в
          журнал, можно применять ключевое  слово <code class="code">log</code> (или <code class="code">log
            (all)</code>) в правилах <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-filter" title="C.2.1.4. Фильтрация пакетов">фильтрации</a>.
        </p><div class="blockquote"><blockquote class="blockquote"><p>
            Лирическое отступление:
          </p><p>
            В 1999 году меня разбил сильный приступ радикулита.
            Родственник доставили меня в диагностический центр и мне
            сделали рентген. После рентгена я получил на руки
            &#171;описание снимка&#187;&nbsp;&#8212; в нём было
            написано шариковой ручкой, что на полученном снимке
            присутствует позвоночник, к которому прикреплены рёбра. А
            сам снимок на руки не давали (видимо из-за серебра...).
            Его давали только врачу, если он сам придёт и попросит.
          </p><p>
            Многие брандмауэры кладут в журнал сообщение о том, что
            через них прошёл некоторый пакет. Могут описать его: мол,
            пакет выглядет так-то и так-то.
          </p><p>
            Пакетный фильтр кладёт в журнал сами пакеты.
          </p></blockquote></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pflog-set"></a>C.2.3.1.1. Помещение пакетов в журнал</h5></div></div></div><p>
            Для журналирования пакета надо поместить ключевое слово <code class="code">log</code> в правило фильтрации, nat или rdr.
            Заметьте, что в пактном фильтре нельзя создать правило
            только для журналирования пакета&nbsp;&#8212; должна
            присутствовать либо директива <code class="code">block</code>
            либо <code class="code">pass</code>.
          </p><p>
            Ключевому слову <code class="code">log</code> можно передать
            следующие опции:
          </p><div class="variablelist"><dl><dt><span class="term"><code class="code">all</code></span></dt><dd>
                Помещает в журнал не только начальные пакеты, но вообще
                все пакеты соединения. Может применяться в правилах <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rule-state" title="C.2.1.4.5. Отслеживание состояния соединения"><code class="code">keep state</code></a>.
              </dd><dt><span class="term"><code class="code">user</code></span></dt><dd>
                Помещает в журнал UID и GID сокета, которому адресован
                пакет.
              </dd><dt><span class="term"><code class="code">to &lt;interface&gt;</code></span></dt><dd>
                Начиная с <span class="acronym">OpenBSD</span>&nbsp;4.1 можно
                создавать несколько интерфейсов для журналирования и
                сообщения от разных правил посылать на разные
                интерфейсы. Ни в одной другой системе эта возможность
                пока не реализована.
              </dd></dl></div><p>
            Опции указываются в круглых скобках после ключевого слова
            <code class="code">log</code>. Несколько опций можно указать
            через запятую или через пробел:
          </p><div class="informalexample"><pre class="programlisting">pass in log (all) on $ext_if inet proto tcp to $ext_if port 22 keep state
            </pre></div><p>
            Это правило помещает в журнал все входящие пакеты, идущие на
            22-й порт.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pflog-read"></a>C.2.3.1.2. Чтение журнала</h5></div></div></div><p>
            Журнальный файл записанный <span><strong class="command">pflogd(8)</strong></span>
            имеет бинарный формат, его нельзя читать при помощи
            текстового редакора. Он предназначен для чтения утилитой
            <span><strong class="command">tcpdump(1)</strong></span> (или другой программой
            скомпилированной с поддержкой библиотеки libpcap, например
            <span><strong class="command">wireshark(1)</strong></span>).
          </p><p>
            Для просмотра журнального файла выполните команду
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> tcpdump -n -e -ttt -r /var/log/pflog
            </pre></div><p>
            Для просмотра журнала в режиме реального времени:
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> tcpdump -n -e -ttt -i pflog0
            </pre></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Warning" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Внимание]" src="pf_02_files/warning.png"></td><th align="left">Внимание</th></tr><tr><td valign="top" align="left"><p>
              При чтении журнала с применением режима verbose
              (активируется флагом <code class="option">-v</code>) будьте
              осторожны: протокол используемый
              <span><strong class="command">tcpdump(1)</strong></span> не имеет безупречной истории
              с точки зрения безопасности. Теоретически, при чтении
              журнала в режиме реального времени, возможна как
              минимум атака приводящая к задержкам в работе системы.
              Рекомендуемая практика состоит в том, чтобы изучать
              журнальные файлы переместив их на другую машину.
            </p><p>
              Кроме того, имейте в виду, что
              <span><strong class="command">pflogd(8)</strong></span> по умолчанию помещает в
              журнал первые 96&nbsp;байт пакета. В этих байтах могут
              находиться критические данные, такие как пароли
              <span><strong class="command">telnet(1)</strong></span> или
              <span><strong class="command">ftp(1)</strong></span>.
            </p></td></tr></tbody></table></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pflog-read-filter"></a>C.2.3.1.3. Фильтрация журнальных данных</h5></div></div></div><p>
            Поскольку <span><strong class="command">pflogd(8)</strong></span> сохраняет данные в
            формате <span><strong class="command">tcpdump(1)</strong></span>, при просмотре данных
            журнала можно использовать правила фильтрации
            <span><strong class="command">tcpdump(1)</strong></span>. Например, для просмотра
            данных касающихся некоторого конкретного порта можно
            применять команду:
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> tcpdump -n -e -ttt -r /var/log/pflog port 80
            </pre></div><p>
            Этот пример можно слегка изменить, чтобы ограничить
            фильтрацию некоторым конкретным хостом:
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> tcpdump -n -e -ttt -r /var/log/pflog port 80 and host 192.168.1.3
            </pre></div><p>
            Та же идея может использоваться при чтении данных из
            устрйства <code class="code">pflog0</code>:
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> tcpdump -n -e -ttt -i pflog0 host 192.168.4.2
            </pre></div><p>
            Правила фильтрации в <span><strong class="command">tcpdump(1)</strong></span>
            специально расширены для взаимодействия с
            <span><strong class="command">pflogd(8)</strong></span>. В данной работе синтаксис
            правил <span><strong class="command">tcpdump(1)</strong></span> подробно рассмотрен в
            <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/ch06s11.html" title="6.11. Демонстрация основных навыков работы с утилитой
      tcpdump(1)">Раздел&nbsp;6.11, &#171;Демонстрация основных навыков работы с утилитой
      <span><strong class="command">tcpdump(1)</strong></span>&#187;</a>, в том же разделе рассматриваются
            <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/ch06s11.html#3.6.11-pflog">дополнительные правила
              <span><strong class="command">tcpdump(1)</strong></span> для работы с журналом
              <span><strong class="command">pflogd(8)</strong></span></a>.
          </p><p>
            Ещё один пример:
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> tcpdump -n -e -ttt -i pflog0 inbound and action block and on wi0
            </pre></div><p>
            В этом примере мы в режиме реального времени следим за
            входящими пакетами блокирующимися на интерфейсе <code class="code">wi0</code>.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pflog-syslog"></a>C.2.3.1.4. Журналирование при помощи <span><strong class="command">syslogd(8)</strong></span></h5></div></div></div><p>
            Во многих случаях желательно вести журнал брандмауэра в
            текстовом формате и отправлять данные журнала на внешний
            журнальный сервер.
          </p><p>
            Увы, никакого естественного метода для этого документация по
            пакетному фильтру нам не предлагает. Всё что нам предлагают,
            это раз в 5 минут пропускать бинарный файл через pipe:
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> tcpdump -n -e -ttt -r /var/log/pflog | logger -t pf -p local0.info
            </pre></div><p>
            Пошаговое HOWTO для направления данных журнала через
            <span><strong class="command">logger(1)</strong></span> демону
            <span><strong class="command">syslogd(8)</strong></span> можно найти <a href="http://www.openbsd.org/faq/pf/logging.html#syslog" target="_top">на
              сайте разработчиков пакетого фильтра</a>. Я не планирую
            пересказывать эту методику в данной книге, так как считаю её
            увечной.
          </p></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-perfomance"></a>C.2.3.2. Производительность</h4></div></div></div><p>
          Насколько большую полосу пропускания может обслуживать
          пакетный фильтр? Насколько мощный компьютер мне нужен для
          обслуживания соединений с Интернет?
        </p><p>
          Простого ответа на эти вопросы нет. Для некоторых целей будет
          достаточно процессора 486/66 с парой хороших сетевых карт ISA,
          при этом будет происходить трансляция NAT и обрабатываться
          трафик до 5&nbsp;Mbps. Для других целей может не будет хватать
          даже более быстрой машины с более мощными сетевыми
          интерфейсами. Оценивать следует не количество байт в секунду,
          а количество пакетов в секунду.
        </p><p>
          Производительность пакетного фильтра определяется несколькими
          величинами:
        </p><div class="itemizedlist"><ul type="disc"><li>
            Количество пакетов в секунду. Нагрузка на вычислительные
            мощности компьютера не зависит от размера полезной нагрузки
            в пакете. Количество пакетов в секунду определяет количество
            запросов к табице состояний и количество правил фильтрации
            вычисляющихся каждую секунду.
          </li><li>
            Производительность вашей системной шины. Максимальная полоса
            пропускания шины ISA 8&nbsp;Mpbs. Если вы достигли этого
            предела, никакой сколь угодно мощный процессор не сможет
            улучшить ситуацию. Шина PCI обладает существенно большей
            пропускной способностью.
          </li><li>
            Производительность вашей сетевой карты. Разные чипсеты
            сетевых карт обладают разной производительностью. Например
            Realtek&nbsp;8139 (rl0) обладает существенно меньшей
            производительностью чем Intel&nbsp;21143 (dc(4)). Для
            максимальной производительности вы можете использовать
            гигабитные карты, даже если вы подсоединяете их к
            100-мегабитной сети&nbsp;&#8212; у гигабитных карт более
            эффективный буфер.
          </li><li>
            Сложность и устройство правил фильтрации. Чем сложнее набор
            правил, тем медленнее работа фильтра. Чем больше пакетов
            фильтруется через правила <code class="code">keep
              state</code> и <code class="code">quick</code> тем лучше
            производительность. Чем больше правил через которые пройдёт
            пакет, тем хуже производительность.
          </li><li>
            Размер и производительность CPU и RAM. Поскольку пакетный
            фильтр работает на уровне ядра, он не использует swap. Если
            ему хватает памяти, он работает, если нет, случится
            &#171;паника&#187;. Большого количества памяти не надо:
            32&nbsp;Mb достаточно для хранения информации о 30000
            соединений в таблице состояний. Этого достаточно для
            небольшого офиса. Многие пользователи на
            &#171;восстановленных из утиля&#187; компьютерах обнаружат
            память до 300&nbsp;Mb. Для них важнее иметь хорошую карту и
            хороший набор правил (см. выше).
          </li></ul></div><p>
          Часто люди спрашивают про benchmark для пакетного фильтра.
          Benchmark для вашей системы с вашим окружением можете сделать
          только вы.
        </p><p>
          Пакетный фильтр используют на некоторых очень больших системах
          с очень большим трафиком. Разработчики&nbsp;&#8212; люди
          компетентные. Это не плохая для вас новость.
        </p><p>
          Подробнее вопросы производительности пакетного фильтра
          изложены в работе Дэниэла Хартмайера [<a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/bi01.html#url://Hartmeier-2006-en" title="[url://Hartmeier-2006-en]">url://Hartmeier-2006-en</a>], [<a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/bi01.html#url://Hartmeier-2006-ru" title="[url://Hartmeier-2006-ru]">url://Hartmeier-2006-ru</a>].
        </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-ftp"></a>C.2.3.3. FTP</h4></div></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-ftp-modes"></a>C.2.3.3.1. Режимы FTP</h5></div></div></div><p>
            FTP это протокол, который создавался, когда Интернет был
            маленький и все в нём друг друга знали. Нужды в фильтрации
            трафика в те годы не было, поэтому FTP сконструирован без
            оглядки на брандмауэры и трансляцию NAT.
          </p><p>
            Существует два режима функционирования FTP: пассивный и
            активный. Выбор между ними, это выбор между тем, у кого
            будут проблемы с фильтрацией трафика. Если вы хотите, чтобы
            ваши пользователи были счастливы, вам придётся
            приспособиться к обоим режимам.
          </p><p><b>Активный FTP.&nbsp;</b>
            Когда клиент посылает серверу команду о передаче данных,
            сервер &#171;ведёт себя активно&#187;&nbsp;&#8212;
            открывает соединение к клиенту. Клиент выбирает случайный
            верхний порт и сообщает его серверу, последний открывает
            соединение на указанный порт клиента для передачи данных.
            Такое поведение затрудняет работу NAT: FTP сервер пытается
            открыть соединение с машиной, на которой работает NAT, а он
            просто не знает, что делать с этими соединениями.
          </p><p><b>Пассивный FTP.&nbsp;</b>
            При передаче данных сервер выбирает случайный верхний порт и
            сообщает его клиенту. Клиент открывает соединение на
            указанный верхний порт сервера, и по этому соединению
            передаются данные. Такая практика не всегда возможна и не
            всегда желательна, так как брандмауэр может блокировать
            трафик идущий на эти случайные порты. Зато с NAT с
            клиентской стороны, напротив нет никаких проблем, так как
            все соединения идут от клиента к серверу.
          </p><p>
            Для тестирования можно применять программу
            <span><strong class="command">ftp(1)</strong></span>. В всех системах
            <span class="acronym">BSD</span> эта программа по умолчанию работает в
            пассивном режиме. В активный режим её можно перевести с
            использованием аргумента <code class="option">-A</code> или уже во
            время работы при помощи команды <code class="code">passive
              off</code> отданной в ответ на приглашение <code class="code"><code class="prompt">ftp&gt;</code></code> (а вернуться
            в пассивный режим командой <code class="code">passive
              on</code>).
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-ftp-client"></a>C.2.3.3.2. FTP клиент за брандмауэром</h5></div></div></div><p>
            Как сказано выше протокол FTP плохо взаимодействует с
            брандмауэрами и NAT.
          </p><p>
            Для решения этой проблемы пакетный фильтр предлагает
            воспользоваться прокси сервером FTP. Этот процесс пропускает
            FTP трафик добавляя и удаляя правила в пакетный фильтр при
            помощи <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-anchors" title="C.2.2.3. Anchors">системы
              якорей</a>. Демон <span><strong class="command">ftp-proxy(8)</strong></span>
            используется пакетным фильтром в
            <span class="acronym">OpenBSD</span>&nbsp;3.9. В старых версиях
            существовал другой демон с тем же названием.
          </p><p>
            Чтобы использовать его, поместите следующие строки в раздел
            NAT файла <code class="filename">/etc/pf.conf(5)</code>:
          </p><div class="informalexample"><pre class="programlisting">nat-anchor "ftp-proxy/*"
rdr-anchor "ftp-proxy/*"
rdr on $int_if proto tcp from any to any port 21 -&gt; 127.0.0.1 port 8021
            </pre></div><p>
            Первые два правила создают пару якорей, которые будут
            использоваться демоном <span><strong class="command">ftp-proxy(8)</strong></span> для
            добавления и удаления правил, т.е. для управления трафиком
            FTP.
          </p><p>
            Последняя строка перенаправляет трафик FTP от клиентов
            программе <span><strong class="command">ftp-poxy(8)</strong></span>, которая будет
            слушать порт 8021.
          </p><p>
            Вам так же понадобится якорь в области фильтрации:
          </p><div class="informalexample"><pre class="programlisting">anchor "ftp-proxy/*"
            </pre></div><p>
            Вам так же понадобится сделать так, чтобы демон
            <span><strong class="command">ftp-proxy(8)</strong></span> стартовал при запуске
            системы. Для этого в <span class="acronym">OpenBSD</span> надо в файл
            <code class="filename">/etc/rc.conf.local</code> добавить строку:
          </p><div class="informalexample"><pre class="programlisting">ftpproxy_flags=""
            </pre></div><p>
            Можно запустить программу вручную, чтобы не перезагружать
            машину.
          </p><p>
            Для работы активного FTP вам понадобится ключ
            <code class="option">-r</code> для <span><strong class="command">ftp-proxy(8)</strong></span>
          </p><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-ftp-proxy-freebsd"></a>C.2.3.3.2.1. Использование <span><strong class="command">ftp-proxy(8)</strong></span> в
              <span class="acronym">FreeBSD</span></h6></div></div></div><p>
              В <span class="acronym">FreeBSD</span> и <span class="acronym">NetBSD</span>
              функциональность <span><strong class="command">ftp-proxy(8)</strong></span> ниже, чем
              в <span class="acronym">OpenBSD</span>. Фактически, в этих системах
              пока применяется устаревшая версия
              <span><strong class="command">ftp-proxy(8)</strong></span>.
              Вместо <span><strong class="command">ftp-proxy(8)</strong></span> в этих системах
              можно использовать порт
              <code class="filename">ftp/ftpsesame</code>. См. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs05.html#pf-ftpsesame" title="C.5.3. ftpsesame">Раздел&nbsp;C.5.3, &#171;ftpsesame&#187;</a>. Далее описано, как
              используется старая версия программы
              <span><strong class="command">ftp-proxy(8)</strong></span>, которой укомплектована
              <span class="acronym">FreeBSD</span>.
            </p><p>
              В <span class="acronym">FreeBSD</span>
              <span><strong class="command">ftp-proxy(8)</strong></span> запускается из
              суперсервера <span><strong class="command">inetd(8)</strong></span>. Для этого в
              <code class="filename">/etc/pf.conf(5)</code> мы добавляем примерно
              такое правило:
            </p><div class="informalexample"><pre class="programlisting">int_if = "xl0"
rdr pass on $int_if proto tcp from any to any port 21 -&gt; 127.0.0.1 port 8021
              </pre></div><p>
              Затем мы конфигурируем <span><strong class="command">inetd(8)</strong></span> так,
              чтобы он начал слушать порт 8021. Для этого в файл
              <code class="filename">/etc/inetd.conf</code> вписываем строку:
            </p><div class="informalexample"><pre class="programlisting">ftp-proxy stream tcp nowait root /usr/libexec/ftp-proxy ftp-proxy
              </pre></div><p>
              Таким образом, <span><strong class="command">ftp-proxy(8)</strong></span>
              пробрасывает командный канал FTP, а для передачи данных
              необходимо добавить разрешающие правила в брандмауэр:
            </p><div class="informalexample"><pre class="programlisting">block in on $ext_if proto tcp all
pass  in on $ext_if inet proto tcp from any to $ext_if \
   port &gt; 49151 keep state
              </pre></div><p>
              Это правило разрешает подключение к портам от 49151 до
              65535. Программе <span><strong class="command">ftp-proxy(8)</strong></span> можно
              задавать диапазоны портов при помощи опций
              <code class="option">-m</code> и <code class="option">-M</code>. Подробнее см.
              <span><strong class="command">man(1)</strong></span> по команде
              <span><strong class="command">ftp-proxy(8)</strong></span>. Диапазон портов
              используемых демоном <span><strong class="command">ftpd(8)</strong></span> в
              <span class="acronym">FreeBSD</span> можно регулировать при помощи
              переменных ядра <code class="code">net.inet.ip.portrange.first</code> <code class="code">net.inet.ip.portrange.last</code>, а в
              <span class="acronym">OpenBSD</span> <code class="code">net.inet.ip.porthifirst</code> и <code class="code">net.inet.ip.porthilast</code>.
            </p><p>
              Надо признать, что вариант с динамическими правилами,
              работающий в <span class="acronym">OpenBSD</span> выглядит разумнее.
              Остаётся надеяться, что в будущем он будет портирован в
              <span class="acronym">FreeBSD</span>, а пока, повторюсь, мы можем
              использовать порт <code class="filename">ftp/ftpsesame</code>.
            </p></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-ftp-server"></a>C.2.3.3.3. FTP сервер защищённый пакетным фильтром запущенным
            непосредственно на нём</h5></div></div></div><p>
            При функционировании пакетного фильтра и FTP сервера на
            одной машине достаточно разрешить в обе стороны коннекты в
            диапазоне портов от 49151 до 65535. Этот диапазон портов
            используется по умолчанию системным FTP серврером
            <span><strong class="command">ftpd(8)</strong></span>. Диапазон портов можно
            регулировать в <span class="acronym">FreeBSD</span> при помощи
            переменных ядра <code class="code">net.inet.ip.portrange.first</code> <code class="code">net.inet.ip.portrange.last</code>, а в
            <span class="acronym">OpenBSD</span> <code class="code">net.inet.ip.porthifirst</code> и <code class="code">net.inet.ip.porthilast</code>.
          </p><div class="informalexample"><pre class="programlisting">pass in on $ext_if proto tcp from any to any port 21 keep state
pass in on $ext_if proto tcp from any to any port &gt; 49151 keep state
            </pre></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-ftp-server-more"></a>C.2.3.3.4. FTP сервер защищённый внешним пакетным фильтром с
            запущенным на нём NAT</h5></div></div></div><p>
            В этом случае брандмауэр должен перенаправлять FTP трафик
            сервера и не блокировать нужные порты. Для этого мы вновь
            приходим к необходимости использовать
            <span><strong class="command">ftp-proxy(8)</strong></span>.
          </p><p>
            <span><strong class="command">ftp-proxy(8)</strong></span> может быть запущен в режиме
            перенаправления всего FTP трафика на один сервер FTP. Обычно
            мы настраиваем брандмауэр так, чтобы он слушал порт 21 и
            пробрасываем трафик на внутренний сервер FTP:
          </p><div class="informalexample"><pre class="programlisting">ftpproxy_flags="-R 10.10.10.1 -p 21 -b 192.168.0.1"
            </pre></div><p>
            Здесь 10.10.10.1&nbsp;&#8212; адрес сервера FTP, а работает
            он на порту 21. 192.168.0.1&nbsp;&#8212; внешний адрес
            брандмауэра, к которому мы привязываем программу
            <span><strong class="command">ftp-proxy(8)</strong></span>.
          </p><p>
            Правила <code class="filename">pf.conf</code>:
          </p><div class="informalexample"><pre class="programlisting">ext_ip = "192.168.0.1"
ftp_ip = "10.10.10.1"

nat-anchor "ftp-proxy/*"
nat on $ext_if inet from $int_if -&gt; ($ext_if)
rdr-anchor "ftp-proxy/*"

pass in on $ext_if inet proto tcp to $ext_ip port 21 \
    flags S/SA keep state
pass out on $int_if inet proto tcp to $ftp_ip port 21 \
    user proxy flags S/SA keep state
anchor "ftp-proxy/*"
            </pre></div><p>
            Опция <code class="code">user proxy</code> нужна для того,
            чтобы убедиться, что только программа
            <span><strong class="command">ftp-proxy(8)</strong></span> может пробрасывать пакеты.
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Замечание]" src="pf_02_files/note.png"></td><th align="left">Замечание</th></tr><tr><td valign="top" align="left">
            В <span class="acronym">FreeBSD</span> и <span class="acronym">NetBSD</span>
            вместо <span><strong class="command">ftp-proxy(8)</strong></span> можно использовать
            порт <code class="filename">ftp/ftpsesame</code>. См. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs05.html#pf-ftpsesame" title="C.5.3. ftpsesame">Раздел&nbsp;C.5.3, &#171;ftpsesame&#187;</a>.
          </td></tr></tbody></table></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-ftp-tftp"></a>C.2.3.3.5. Проксирование TFTP</h5></div></div></div><p>
            Для работы с протоколом TFTP в <span class="acronym">OpenBSD</span>
            применяется другая программа-помошник&nbsp;&#8212;
            <span><strong class="command">tftp-proxy(8)</strong></span>. В отличие от
            <span><strong class="command">ftp-proxy(8)</strong></span> она должна запускаться из
            <span><strong class="command">inetd(8)</strong></span>.
          </p></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-authpf"></a>C.2.3.4. Authpf: авторизация в пакетном фильтре</h4></div></div></div><p>
          <span><strong class="command">authpf(8)</strong></span>&nbsp;&#8212; пользовательская
          оболочка для авторизации на шлюзе. При использовании этой
          программы шлюз работает как обычный маршрутизатор, но
          пропускает пользовательский трафик только если пользователь
          аутентифицировался на нём. Если пользовательская оболочка
          выставлена в <code class="filename">/etc/sbin/authpf</code> (т.е.
          вместо <span><strong class="command">csh(1)</strong></span> и пр.) и пользователь зашёл в
          систему, например через <span><strong class="command">ssh(1)</strong></span>,
          <span><strong class="command">authpf(8)</strong></span> динамически настраивает пакетный
          фильтр так, чтобы он начал пропускать трафик пользователя,
          осуществлял нужные пользователю перенаправления и трансляции.
          Когда пользователь прекращает сессию
          <span><strong class="command">ssh(1)</strong></span>, <span><strong class="command">authpf(8)</strong></span>
          удаляет правила из пакетного фильтра и удаляет записи из
          таблицы состояний. Таким образом, пользователь способен
          сохранять соединение только пока открыта сессия
          <span><strong class="command">ssh(1)</strong></span>.
        </p><p>
          <span><strong class="command">authpf(8)</strong></span> загружает правила фильтрации и
          трансляции используя  уникальный для каждого пользователя
          <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-anchors" title="C.2.2.3. Anchors">якорь</a>. Название
          якоря является комбинацией из имени пользователя и PID
          экземпляра <span><strong class="command">authpf(8)</strong></span> в формате <code class="code">username(PID)</code>. Каждый пользовательский
          якорь находится внутри якоря <code class="code">authpf</code>, который уже находится в
          основном наборе правил. Таким образом, &#171;полностью
          разрешённое имя якоря&#187; выглядит как
        </p><div class="informalexample"><pre class="programlisting">main_ruleset/authpf/username(PID)
          </pre></div><p>
          Правила, которые может загрузить <span><strong class="command">authpf(8)</strong></span>
          могут быть индивидуальными для каждого пользователя, а могут
          быть глобальными.
        </p><p>
          Вот примеры использования <span><strong class="command">authpf(8)</strong></span>:
        </p><div class="itemizedlist"><ul type="disc"><li>
            Требование от пользователя аутентифицироваться перед выходом
            в Интернет.
          </li><li>
            Выдача некоторым пользавателям (администраторам) прав
            доступа к закрытой области сети.
          </li><li>
            Предоставление только известным пользователям возможности
            доступа к Интернет из беспроводной сети (мало ли какой
            прохожий с ноутбуком появится в беспроводной сети).
          </li><li>
            Предоставление людям работающим дома или путешествующим по
            миру доступа к сети компании. Пользователи находящиеся вне
            офиса могут не только зайти в сеть предприятия, но так же
            могут быть перенаправлены на свой desktop на основании
            введённого ими логина и пароля.
          </li><li>
            В местах с публично доступным Интернетом (библиотеках и
            т.п.) может быть настроен ограниченный доступ в Интернет для
            гостей, а зарегистрированным при помощи
            <span><strong class="command">authpf(8)</strong></span> пользователям предоставлен
            полный доступ к Интернет.
          </li></ul></div><p>
          Информация об аутентифицировавшихся пользователях
          журналируется через <span><strong class="command">syslogd(8)</strong></span>. Это
          позволяет администратору вычислять кто когда пользовался
          Интернетом и вычислять какой пользователь использовал большее
          количество трафика.
        </p><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-authpf-conf"></a>C.2.3.4.1. Конфигурирование <span><strong class="command">authpf(8)</strong></span></h5></div></div></div><p>
            Полностью конфигурирование <span><strong class="command">authpf(8)</strong></span>
            описано в <span><strong class="command">man(1)</strong></span> странице по
            <span><strong class="command">authpf(8)</strong></span>.
          </p><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-authpf-conf-enable"></a>C.2.3.4.1.1. Включение <span><strong class="command">authpf(8)</strong></span></h6></div></div></div><p>
              В системе должен существовать конфигурационный файл
              <code class="filename">/etc/authpf/authpf.conf</code>. В нём
              содержатся конфигурационные опции
              <span><strong class="command">authpf(8)</strong></span>. Если файла не существует,
              <span><strong class="command">authpf(8)</strong></span> будет завершать работу сразу
              после аутентификации. Если он существует, но пуст, будут
              использованы умолчания.
            </p><p>
              В этом файле могут присутствовать следующие две опции:
            </p><div class="variablelist"><dl><dt><span class="term"><code class="code">anchor=name</code></span></dt><dd>
                  Использование <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-anchors" title="C.2.2.3. Anchors">якоря</a>&nbsp;<code class="code">name</code> вместо
                  <span><strong class="command">authpf</strong></span></dd><dt><span class="term"><code class="code">table=name</code></span></dt><dd>
                  Использование <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-tables" title="C.2.1.3. Таблицы">таблицы</a>&nbsp;<code class="code">table</code> вместо
                  <span><strong class="command">authpf_users</strong></span>.
                </dd></dl></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-authpf-conf-main"></a>C.2.3.4.1.2. Помещение <span><strong class="command">authpf(8)</strong></span> в основной
              набор правил</h6></div></div></div><p>
              <span><strong class="command">authpf(8)</strong></span> помещается в основной набор
              правил при помощи правила <code class="code">anchor</code>:
            </p><div class="informalexample"><pre class="programlisting">nat-anchor "authpf/*"
rdr-anchor "authpf/*"
binat-anchor "authpf/*"
anchor "authpf/*"
              </pre></div><p>
              Пакетный фильтр перейдёт к изучению правил входящих в эти
              якоря там, где они расположены. Нет нужды всегда
              использовать все якоря. Например, если
              <span><strong class="command">authpf(8)</strong></span> не настроен на то, чтобы
              осуществлять трансляцию NAT, то соответствующий якорь не
              нужен.
            </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-authpf-conf-rules"></a>C.2.3.4.1.3. Настройка подгружаемых правил</h6></div></div></div><p>
              <span><strong class="command">authpf(8)</strong></span> подгружает правила из файлов
            </p><div class="itemizedlist"><ul type="disc"><li><code class="filename">/etc/authpf/users/$USER/authpf.rules</code></li><li><code class="filename">/etc/authpf/authpf.rules</code></li></ul></div><p>
              Сперва ищется первый, потом второй, если существуют
              оба&nbsp;&#8212; используется только один. Таким образом,
              в первом файле должны находится правила характерные для
              конкретного пользователя и они будут перебивать глобальные
              правила заданные во втором файле. Как минимум один файл
              должен существовать, иначе <span><strong class="command">authpf(8)</strong></span> не
              запустится.
            </p><p>
              Правила трансляции такие же как и в основном файле, однако
              определены два макроса:
            </p><div class="variablelist"><dl><dt><span class="term"><code class="code">$user_ip</code></span></dt><dd>
                  IP адрес с которого пришёл пользователь.
                </dd><dt><span class="term"><code class="code">$user_id</code></span></dt><dd>
                  Имя залогинившегося пользователя.
                </dd></dl></div><p>
              Рекомендуется использовать <code class="code">$user_id</code> для того, чтобы был
              разрешён только трафик с пользовательской машины.
            </p><p>
              В добавок к макросу <code class="code">$user_ip</code>
              <span><strong class="command">authpf(8)</strong></span> может использовать для
              хранения всех аутентифицировавшихся пользователей таблицу
              <code class="code">authpf_users</code> если она
              существует. Убедитесь, что вы определили её, прежде чем
              использовать:
            </p><div class="informalexample"><pre class="programlisting">table &lt;authpf_users&gt; persist
pass in on $ext_if proto tcp from &lt;authpf_users&gt; \
    to port smtp flags S/SA keep state
              </pre></div><p>
              Эта таблица должна использоваться в правилах, которые
              относятся ко всем аутентифицировавшимся пользователям.
            </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-authpf-conf-acl"></a>C.2.3.4.1.4. Списки доступа</h6></div></div></div><p>
              Пользователям можно запретить пользоваться
              <span><strong class="command">authpf(8)</strong></span> для этого надо создать файл в
              каталоге <code class="filename">/etc/authpf/banned/</code>. Файл
              должен называться по имени пользователя. Его содержимое
              будет показано пользователю перед обрывом связи. Таким
              образом, в нём можно указать причины прекращения доступа и
              как связаться с ответственным лицом.
            </p><p>
              Кроме того, в файле
              <code class="filename">/etc/authpf/authpf.allow</code> можно
              перечислить пользователей, которым разрешено входить в
              систему с использованием <span><strong class="command">authpf(8)</strong></span>.
              Если файл существует, действует политика &#171;что не
              разрешено, то запрещено&#187;. Если файла нет, или если в
              нём звёздочка <code class="code">*</code>&nbsp;&#8212;
              <span><strong class="command">authpf(8)</strong></span> позволяет зайти всем, кто
              успешно залогинился через <span><strong class="command">ssh(1)</strong></span>, если
              только его не &#171;забанили&#187; в каталоге
              <code class="filename">/etc/authpf/banned/</code>.
            </p><p>
              Если <span><strong class="command">authpf(8)</strong></span> не может определить
              разрешено польователю входить или нет, он печатает
              предупреждение и не пускает пользователя.
              <code class="filename">/etc/authpf/banned/</code> всегда главнее
              <code class="filename">/etc/authpf/authpf.allow</code>.
            </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-authpf-conf-message"></a>C.2.3.4.1.5. Приветствие</h6></div></div></div><p>
              Когда пользователь успешно аутентифицируется в системе,
              ему будет напечатано приветственное сообщение
            </p><div class="informalexample"><pre class="programlisting">Hello charlie. You are authenticated from host "64.59.56.140"
              </pre></div><p>
              Это сообщение можно дополнить сообщением из файла
              <code class="filename">/etc/authpf/authpf.message</code>.
            </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-authpf-conf-shell"></a>C.2.3.4.1.6. Настройка <span><strong class="command">authpf(8)</strong></span> в качестве
              пользовательской оболочки</h6></div></div></div><p>
              Чтобы <span><strong class="command">authpf(8)</strong></span> заработал, его надо
              сделать оболочкой пользователя. Когда пользователь успешно
              зайдёт в систему через <span><strong class="command">ssh(1)</strong></span>,
              <span><strong class="command">authpf(8)</strong></span> будет запущен в качестве
              оболочки. Он проверит можно ли пользователю его
              использовать, загрузит нужные правила и т.д.
            </p><p>
              Есть два способа назначить пользователю
              <span><strong class="command">authpf(8)</strong></span> в качестве оболочки:
            </p><div class="itemizedlist"><ul type="disc"><li>
                Вручную, каждому пользователю, используя утилиты
                <span><strong class="command">chsh(1)</strong></span>, <span><strong class="command">vipw(8)</strong></span>,
                <span><strong class="command">adduser(8)</strong></span>, <span><strong class="command">pw(8)</strong></span>,
                (последние две в <span class="acronym">FreeBSD</span>),
                <span><strong class="command">useradd(8)</strong></span>,
                <span><strong class="command">usermod(8)</strong></span> (последние две в
                <span class="acronym">OpenBSD</span>), и пр.
              </li><li>
                Назначив пользователю класс с изменённой оболочкой,
                посредством файла <code class="filename">login.conf(5)</code>.
                (см. <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apf.html" title="Приложение F. /etc/login.conf(5)">Приложение&nbsp;F, <i><code class="filename">/etc/login.conf(5)</code></i></a>).
              </li></ul></div></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-authpf-class"></a>C.2.3.4.2. Создание класса authpf для <code class="filename">/etc/login.conf(5)</code></h5></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Замечание]" src="pf_02_files/note.png"></td><th align="left">Замечание</th></tr><tr><td valign="top" align="left">
            Что такое классы, зачем они нужны, как их создавать,
            подробно описано в <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apf.html" title="Приложение F. /etc/login.conf(5)">Приложение&nbsp;F, <i><code class="filename">/etc/login.conf(5)</code></i></a>.
          </td></tr></tbody></table></div><p>
            В системе, где есть одновременно обычные пользователи и
            пользователи для <span><strong class="command">authpf(8)</strong></span> удобно создать
            для последних специальный класс. Это позволит сделать разные
            политики для разных пользователей. Например, в классе можно
            указать:
          </p><div class="variablelist"><dl><dt><span class="term"><code class="code">shell</code></span></dt><dd>
                Можно жёстко указать пользователям оболочку
                <code class="filename">/usr/sbin/authpf</code> так, что её
                невозможно будет сменить через программу
                <span><strong class="command">chsh(1)</strong></span>&nbsp;&#8212; эта опция
                <code class="filename">login.conf(5)</code> имеет приоритет перед
                содержимым файла <code class="filename">passwd(5)</code>.
              </dd><dt><span class="term"><code class="code">welcome</code></span></dt><dd>
                Можно сделать разное приветствие для разных типов
                пользоватлей.
              </dd></dl></div><p>
            Класс создаётся в файле
            <code class="filename">/etc/login.conf</code>. Вот пример класса для
            пользователей <span><strong class="command">authpf(8)</strong></span>:
          </p><div class="informalexample"><pre class="programlisting">authpf:\
    :welcome=/etc/motd.authpf:\
    :shell=/usr/sbin/authpf:\
    :tc=default:
            </pre></div><p>
            После редактирования файла
            <code class="filename">/etc/login.conf</code> не забудьте выполнить
            команду
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> cap_mkdb /etc/login.conf
            </pre></div><p>
            Назначить пользователю класс можно разными способами.
            Например: <span><strong class="command">chsh(1)</strong></span>,
            <span><strong class="command">pw(8)</strong></span>, <span><strong class="command">vipw(8)</strong></span>.
          </p><p>
            Чтобы просмотреть список пользователей из класса authpf,
            можно выполнить такую команду:
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> awk -F: '$5=="authpf"{print $1}' /etc/master.passwd | sort
            </pre></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-authpf-log"></a>C.2.3.4.3. Кто зашёл в систему через <span><strong class="command">authpf(8)</strong></span>?</h5></div></div></div><p>
            После того, как пользователь успешно вошёл в систему,
            <span><strong class="command">authpf(8)</strong></span> меняет заголовок процесса,
            помещая в него имя пользователя и IP адрес с которого он
            пришёл:
          </p><div class="informalexample"><pre class="screen"><code class="prompt">$</code> ps -ax | grep authpf
23664 p0  Is+     0:00.11 -authpf: charlie@192.168.1.3 (authpf)
            </pre></div><p>
            Послав этому процессу сигнал <code class="varname">SIGTERM</code>
            можно насильно прервать сессию пользователя. При этом
            <span><strong class="command">authpf(8)</strong></span> удалит все правила из пакетного
            фильтра и прекратит коннект пользователя.
            <span class="emphasis"><em>А если послать сигнал <code class="varname">SIGKILL</code>,
            то не удалит, и пользователь по прежнему будет ходить через
            шлюз!</em></span>
        </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> kill -TERM 23664
          </pre></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-authpf-example"></a>C.2.3.4.4. Пример</h5></div></div></div><p>
            Пусть пакетный фильтр используется на машине
            <span class="acronym">OpenBSD</span>, которая является шлюзом для
            беспроводной сети, которая является частью большой
            университетской сети. Если пользователь аутентифицировался,
            и он не находится в списке запрещённых пользователей
            (<code class="filename">/etc/authpf/banned/</code>), ему разрешают
            SSH наружу, использовать web, и, конечно, открывают доступ к
            DNS.
          </p><p>
            Файл <code class="filename">/etc/authpf/authpf.rules</code> содержит
            следующие строки:
          </p><div class="informalexample"><pre class="programlisting">wifi_if = "wi0"

pass in quick on $wifi_if proto tcp from $user_ip to port { ssh, http, \
   https } flags S/SA keep state
            </pre></div><p>
            Администратор charlie должен иметь доступ к SMTP, POP3, а
            так же web и SSH.
          </p><p>
            Файл
            <code class="filename">/etc/authpf/users.charlie/authpf.rules</code>
            содержит следующие строки:
          </p><div class="informalexample"><pre class="programlisting">wifi_if = "wi0"
smtp_server = "10.0.1.50"
pop3_server = "10.0.1.51"

pass in quick on $wifi_if proto tcp from $user_ip to $smtp_server \
   port smtp flags S/SA keep state
pass in quick on $wifi_if proto tcp from $user_ip to $pop3_server \
   port pop3 flags S/SA keep state
pass in quick on $wifi_if proto tcp from $user_ip to port { ssh, http, \
   https } flags S/SA keep state
            </pre></div><p>
            Основной файл с правилами, расположенный в
            <code class="filename">/etc/pf.conf</code> содержит следующие строки:
          </p><div class="informalexample"><pre class="programlisting"># macros
wifi_if = "wi0"
ext_if  = "fxp0"
dns_servers = "{ 10.0.1.56, 10.0.2.56 }"

table &lt;authpf_users&gt; persist

scrub in all

# filter
block drop all <a name="pf-authpf-ex1-area" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-authpf-ex1-co"><img src="pf_02_files/1.png" alt="1" border="0"></a>

pass out quick on $ext_if inet proto tcp from \
   { $wifi_if:network, $ext_if } flags S/SA modulate state
pass out quick on $ext_if inet proto { udp, icmp } from \
   { $wifi_if:network, $ext_if } keep state <a name="pf-authpf-ex2-area" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-authpf-ex2-co"><img src="pf_02_files/2.png" alt="2" border="0"></a>

pass in quick on $wifi_if inet proto tcp from $wifi_if:network to $wifi_if \
   port ssh flags S/SA keep state <a name="pf-authpf-ex3-area" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-authpf-ex3-co"><img src="pf_02_files/3.png" alt="3" border="0"></a>

pass in quick on $wifi_if inet proto { tcp, udp } from &lt;authpf_users&gt; \
   to $dns_servers port domain keep state <a name="pf-authpf-ex4-area" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-authpf-ex4-co"><img src="pf_02_files/4.png" alt="4" border="0"></a>
anchor "authpf/*" in on $wifi_if <a name="pf-authpf-ex5-area" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-authpf-ex5-co"><img src="pf_02_files/5.png" alt="5" border="0"></a>
            </pre></div><p>
            Правила очень просты. Вот, что они значат:
          </p><div class="calloutlist"><table summary="Callout list" border="0"><tbody><tr><td valign="top" width="5%" align="left"><a name="pf-authpf-ex1-co"></a><a href="#pf-authpf-ex1-area"><img src="pf_02_files/1.png" alt="1" border="0"></a> </td><td valign="top" align="left">
                Блокируем весь трафик (политика default deny).
              </td></tr><tr><td valign="top" width="5%" align="left"><a name="pf-authpf-ex2-co"></a><a href="#pf-authpf-ex2-area"><img src="pf_02_files/2.png" alt="2" border="0"></a> </td><td valign="top" align="left">
                Пропускаем весь исходящий трафик (TCP, UDP и ICMP) на
                внешнем интерфейсе шлюза, как из беспроводной сети, так
                и идущий с самого шлюза.
              </td></tr><tr><td valign="top" width="5%" align="left"><a name="pf-authpf-ex3-co"></a><a href="#pf-authpf-ex3-area"><img src="pf_02_files/3.png" alt="3" border="0"></a> </td><td valign="top" align="left">
                Пропускаем входящий трафик SSH из беспроводной сети
                (нужно для аутентификации).
              </td></tr><tr><td valign="top" width="5%" align="left"><a name="pf-authpf-ex4-co"></a><a href="#pf-authpf-ex4-area"><img src="pf_02_files/4.png" alt="4" border="0"></a> </td><td valign="top" align="left">
                Пропускаем запросы DNS от аутентифицировавшихся
                пользователей.
              </td></tr><tr><td valign="top" width="5%" align="left"><a name="pf-authpf-ex5-co"></a><a href="#pf-authpf-ex5-area"><img src="pf_02_files/5.png" alt="5" border="0"></a> </td><td valign="top" align="left">
                Создаём якорь для <span><strong class="command">authpf(8)</strong></span>.
              </td></tr></tbody></table></div><p>
            Основная идея в том, чтобы заблокировать всё и открыть
            настолько мало, насколько это возможно. Трафик может
            свободно покидать внешний интерфейс, однако он заблокирован
            политикой default deny на внутреннем (wi0) интерфейсе. Когда
            пользователь аутентифицируется, его трафик оказывается
            разрешён для прохода на внутреннем интерфейсе и, таким
            образом, проходит наружу. Ключевое слово <code class="code">quick</code> используется для того, чтобы
            добавляемые на лету правила не сказывались на конструкции
            брандмауэра.
          </p></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-carp+pfsync"></a>C.2.3.5. <span class="acronym">CARP</span> и pfsync</h4></div></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-carp-intro"></a>C.2.3.5.1. Введение в <span class="acronym">CARP</span></h5></div></div></div><p>
            <span class="acronym">CARP</span>&nbsp;&#8212; Common Address
            Redundancy Protocol (Общий Протокол Избыточных Адресов, я не
            знаю есть ли общепринятый перевод на русский язык). Основная
            задача протокола&nbsp;&#8212; дать возможность различным
            хостам в локальной сети использовать общий IP адрес.
            <span class="acronym">CARP</span> является свободной и безопасной
            альтернативой протоколам <span class="acronym">VRRP</span> (Virtual
            Router Redundancy Protocol, см. [<a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/bi01.html#RFC-3768" title="[RFC-3768]">RFC-3768</a>]) и <span class="acronym">HSRP</span> (Hot
            Standby Router Protocol, см. [<a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/bi01.html#RFC-2281" title="[RFC-2281]">RFC-2281</a>]). К сожалению, на этот протокол не
            опубликовано RFC. Кроме того, уже сужествует другой протокол
            с тем же названием: (Cache Array Routing Protocol,
            [<a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/bi01.html#RFC-3040" title="[RFC-3040]">RFC-3040</a>]&nbsp;&#8212; протокол
            используемый Microsoft&nbsp;ISA).
          </p><div class="blockquote"><blockquote class="blockquote"><p>
              История вопроса такова (по данным wikipedia): В конце 90-х годов
              <span class="acronym">IETF</span> начало работу над проблемой
              отказоустойчивости сервисов. В 1997 году Cisco
              проинформировало, что проблема уже решена при помощи
              запатентованной ими технологии. В 1998 году Cisco
              опубликовала запатентованный протокол
              <span class="acronym">HSRP</span>. Несмотря на это IETF продолжила
              работу над своим протоколом <span class="acronym">VRRP</span>. После
              некоторых дебатов было решено, что запатентованную
              технологию можно использовать в качестве стандарта при
              условии лицензирования по &#171;разумной и не
              дискриминационной&#187; лицензии. Однако, поскольку
              <span class="acronym">VRRP</span> решало некоторые проблемы
              <span class="acronym">HSRP</span> сама Cisco перешла на использование
              <span class="acronym">VRRP</span> при этом называя его своим.
            </p><p>
              Cisco проинформировала разработчиков
              <span class="acronym">OpenBSD</span>, что они не могут использовать
              патентованный <span class="acronym">VRRP</span>. Возможно это было
              связано с судебными тяжбами Cisco с Alсatel (звучит
              загадочно&nbsp;&#8212; Е.М.). Таким образом, свободную
              реализацию <span class="acronym">VRRP</span> сделать было нельзя,
              поэтому <span class="acronym">OpenBSD</span> принялись за разработку
              альтернативного протокола <span class="acronym">CARP</span>.
            </p><p>
              В настоящий момент <span class="acronym">CARP</span> реализован не
              только в <span class="acronym">OpenBSD</span>, но так же портирован в
              <span class="acronym">FreeBSD</span> и <span class="acronym">NetBSD</span> (и,
              следовательно в <span class="acronym">DragonFly&nbsp;BSD</span>).
            </p><p>
              IANA до сих по не выделила официальный номер протокола для
              <span class="acronym">CARP</span>. Это связано, по всей видимости, с
              отсутствием его описания. Разработчики
              <span class="acronym">OpenBSD</span> самовольно присвоили ему номер
              112 (конфликтующий с <span class="acronym">VRRP</span>). То же
              касается и протокола <code class="code">pfsync</code>.
            </p></blockquote></div><p>
            <span class="acronym">CARP</span> позволяет группе хостов использовать
            общий IP адрес. Эта группа хостов называется
            &#171;избыточная группа&#187; (redundancy group). Избыточной
            группе присваивается общий адрес, затем, среди её членов
            назначается &#171;мастер&#187; и запасные машины (backup).
            Мастер, это та машина, которой в данный момент принадлежит
            общий адрес IP. Он отвечает на ARP запросы, обращённые к
            этому адресу. Каждый хост может принадлежать более чем к
            одной &#171;избыточной группе&#187;.
          </p><p>
            Один из способов использования CARP&nbsp;&#8212; построение
            избыточных брандмауэров. Виртуальный IP адрес, принадлежащий
            группе, указывают клиентам в качестве маршрута по умолчанию.
            Если брандмауэр оказывается недоступен, IP адрес переходит к
            другой, запасной машине в группе и работа сети продолжается.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-carp-operation"></a>C.2.3.5.2. Как работает <span class="acronym">CARP</span></h5></div></div></div><p>
            Мастер-хост группы регулярно посылает оповещения в локальную
            сеть, чтобы запасные хосты знали, что он ещё жив. Если
            запасной хост в течении некоторого времени не получает
            уведомления от мастера, то он может принять на себя
            обязанности мастера. (Какой именно&nbsp;&#8212; зависит от
            значения <code class="code">advbase</code> и <code class="code">advskew</code>).
          </p><p>
            В одной локальной сети может находиться несколько групп
            <span class="acronym">CARP</span>, так как в оповещении, рассылаемом
            мастером присутствует Virtual Host ID, по которому запасные
            машины могут понять какой группе адресовано оповещение.
          </p><p>
            Чтобы предотвратить рассылку поддельных оповещений
            <span class="acronym">CARP</span>, каждая группа может быть
            сконфигурирована с паролем. Каждый пакет
            <span class="acronym">CARP</span> снабжается этим паролем в виде SHA1
            HMAC.
          </p><p>
            <span class="acronym">CARP</span> рассылается при помощи собственного
            протокола сетевого уровня (номер 112, официально не
            утверждён IANA) и ему нужно отдельное правило в брандмауэре:
          </p><div class="informalexample"><pre class="programlisting">pass out on $carp_dev proto carp keep state
            </pre></div><p>
            Здесь <code class="code">$carp_dev</code>&nbsp;&#8212;
            физический интерфейс через который передаются оповещения
            <span class="acronym">CARP</span>.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-carp-config"></a>C.2.3.5.3. Настройка CARP</h5></div></div></div><p>
            Каждая группа <span class="acronym">CARP</span> представлена
            виртуальным сетевым интерфейсом <code class="code">carp(4)</code>. Таким образом,
            <span class="acronym">CARP</span> можно настроить используя команду
            <span><strong class="command">ifconfig(8)</strong></span>:
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> ifconfig &lt;carpN&gt; create

<code class="prompt">#</code> ifconfig &lt;carpN&gt; vhid &lt;vhid&gt; [pass &lt;password&gt;] [carpdev &lt;carpdev&gt;] \
   [advbase &lt;advbase&gt;] [advskew &lt;advskew&gt;] [state &lt;state&gt;] &lt;ipaddress&gt; \
   netmask &lt;mask&gt;
            </pre></div><div class="variablelist"><dl><dt><span class="term"><code class="code">carpN</code></span></dt><dd>
                Имя интерфейса. <code class="code">N</code>&nbsp;&#8212; целое число,
                номер интерфейса, например 10.
              </dd><dt><span class="term"><code class="code">vhid</code></span></dt><dd>
                Virtual host ID&nbsp;&#8212; идентификатор группы
                <span class="acronym">CARP</span>. Целое число от 1 до 255.
              </dd><dt><span class="term"><code class="code">password</code></span></dt><dd>
                Пароль группы для аутентификации членов группы. Должен
                быть общим для всех членов группы.
              </dd><dt><span class="term"><code class="code">carpdev</code></span></dt><dd>
                Физический интерфейс принадлежащий группе.
                Необязательный параметр. По умолчанию
                <span class="acronym">CARP</span> пытается самостоятельно
                определить интерфейс на основе IP-адреса и маски
                подсети. Аргумент отсутствует в
                <span class="acronym">FreeBSD</span>.
              </dd><dt><span class="term"><code class="code">advbase</code></span></dt><dd>
                Необязательный параметр указывающий на то, как часто
                рассылаются уведомления в группе. По умолчанию 1.
                Допустимые значения от 1 до 255.
              </dd><dt><span class="term"><code class="code">advskew</code></span></dt><dd>
                Необязательный параметр указывает на то, насколько может
                изменяться величина <code class="code">advbase</code>.
                На основе величин <code class="code">advbase</code> и
                <code class="code">advskew</code> происходит выбор
                мастера в группе: чем меньше <code class="code">advbase</code>, который может
                использовать хост, тем выше у него приоритет. По
                умолчанию 0. Допустимые значения от 0 до 254.
              </dd><dt><span class="term"><code class="code">state</code></span></dt><dd>
                Заставить виртуальный интерфейс перейти в данное
                состояние. Допустимые состояния <code class="code">init</code>, <code class="code">backup</code>, <code class="code">master</code>. Аргумент отсутствует в
                <span class="acronym">FreeBSD</span>.
              </dd><dt><span class="term"><code class="code">ipaddress</code></span></dt><dd>
                Адрес присвоенный группе. Он не обязан нахоиться в той
                же сети, что и физический интерфейс. Необходимо, чтобы
                он совпадал у всех членов группы.
              </dd><dt><span class="term"><code class="code">mask</code></span></dt><dd>
                Маска подсети для обобществлённого адреса.
              </dd></dl></div><p>
            Поведением <span class="acronym">CARP</span> пожно управлять через
            <span><strong class="command">sysctl(8)</strong></span>. Вот некоторые переменные ядра:
          </p><p>
            Приведённые ниже переменные ядра работают как в
            <span class="acronym">OpenBSD</span>, так и в
            <span class="acronym">FreeBSD</span>:
          </p><div class="variablelist"><dl><dt><span class="term"><code class="varname">net.inet.carp.allow</code></span></dt><dd>
                Принимать или нет пакеты <span class="acronym">CARP</span>.
                Умолчание 1 (да).
              </dd><dt><span class="term"><code class="varname">net.inet.carp.preempt</code></span></dt><dd><p>
                  Позволяет мастеру передать его обязанности другим
                  членам группы <span class="acronym">CARP</span> имеющим лучшие
                  показатели <code class="code">advbase</code> и <code class="code">advskew</code>. Кроме того, позволяет
                  обработать ситуацию отказа&nbsp;&#8212; если
                  физический интерфейс отказал, на других интерфейсах с
                  включённым <span class="acronym">CARP</span> <code class="code">advskew</code> выставляется в 240.
                </p><p>
                  Поясню: Пусть имеется маршрутизатор A с двумя
                  интерфейсами в <span class="acronym">CARP</span> и <code class="code">advskew=0</code> и маршрутизатор B с
                  <code class="code">advskew=100</code>. Если данная
                  переменная ядра выставлена в истину, и на
                  маршрутизаторе A падает один интерфейс. В этом случае
                  <code class="code">advskew</code> на A увеличивается
                  до 240 и обязанности мастера берёт маршрутизатор B.
                </p><p>
                  По умолчанию выставлен в 0 (нет)
                </p></dd><dt><span class="term"><code class="varname">net.inet.carp.log</code></span></dt><dd>
                Помещать в журнал информацию о плохих пакетах
                <span class="acronym">CARP</span>. В <span class="acronym">OpenBSD</span> по
                умолчанию 0 (отключено). В <span class="acronym">FreeBSD</span> по
                умолчанию 1 (журналирование неправильных пакетов). В
                <span class="acronym">FreeBSD</span> значение 2 помещает в журнал
                информацию о смене состояния <span class="acronym">CARP</span>
                интерфейса. Вероятно это значение работает и в
                <span class="acronym">OpenBSD</span>, но оно там
                недокументировано.
              </dd><dt><span class="term"><code class="varname">net.inet.carp.arpbalance</code></span></dt><dd>
                Балансировка ARP запросов. Кто будет отвечать на вопросы
                о том, у кого имеется данный IP адрес. По умолчанию
                выключено.
              </dd></dl></div><p>
            Дополнительную информацию можно получить из руководства
            <span><strong class="command">man(1)</strong></span> по <code class="code">carp(4)</code> и из [<a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/bi01.html#url://Sgibnev-CARP-2006" title="[url://Sgibnev-CARP-2006]">url://Sgibnev-CARP-2006</a>].
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-carp-example"></a>C.2.3.5.4. Пример <span class="acronym">CARP</span></h5></div></div></div><p>
            Пример конфигурации <span class="acronym">CARP</span>:
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> sysctl -w net.inet.carp.allow=1 <a name="pf-carp-ex1-area" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-carp-ex1-co"><img src="pf_02_files/1.png" alt="1" border="0"></a>
<code class="prompt">#</code> ifconfig carp1 create <a name="pf-carp-ex2-area" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-carp-ex2-co"><img src="pf_02_files/2.png" alt="2" border="0"></a>
<code class="prompt">#</code> ifconfig carp1 vhid 1 pass mekmitasdigoat carpdev em0 \
    advskew 100 10.0.0.1 netmask 255.255.255.0 <a name="pf-carp-ex3-area" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-carp-ex3-co"><img src="pf_02_files/3.png" alt="3" border="0"></a>
            </pre></div><div class="calloutlist"><table summary="Callout list" border="0"><tbody><tr><td valign="top" width="5%" align="left"><a name="pf-carp-ex1-co"></a><a href="#pf-carp-ex1-area"><img src="pf_02_files/1.png" alt="1" border="0"></a> </td><td valign="top" align="left">
                Включить приём пакетов <span class="acronym">CARP</span> (это
                умолчание).
              </td></tr><tr><td valign="top" width="5%" align="left"><a name="pf-carp-ex2-co"></a><a href="#pf-carp-ex2-area"><img src="pf_02_files/2.png" alt="2" border="0"></a> </td><td valign="top" align="left">
                Создаётся интерфейс <code class="code">carp1</code>.
              </td></tr><tr><td valign="top" width="5%" align="left"><a name="pf-carp-ex3-co"></a><a href="#pf-carp-ex3-area"><img src="pf_02_files/3.png" alt="3" border="0"></a> </td><td valign="top" align="left">
                Конфигурируется созданный интерфейс: ему присваивается
                vid=1 (хост id), устанавливается пароль, назначается
                физический интерфейс <code class="code">em0</code>,
                данный хост назначается запасным (скорее всего у мастера
                <code class="code">advskew&lt;100</code>). Наконец
                обобществлённый адрес становится 10.0.0.1/24.
              </td></tr></tbody></table></div><p>
            Чтобы просмотреть состояние интерфейса <code class="code">carp1</code> мы можем вновь использовать
            команду <span><strong class="command">ifconfig(8)</strong></span>
          </p><div class="informalexample"><pre class="screen"><code class="prompt">$</code> ifconfig carp1
carp1: flags=8802&lt;UP,BROADCAST,SIMPLEX,MULTICAST&gt; mtu 1500
     carp: BACKUP carpdev em0 vhid 1 advbase 1 advskew 100
     groups: carp
     inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
            </pre></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pfsync-intro"></a>C.2.3.5.5. Введение в pfsync(4)</h5></div></div></div><p>
            Интерфейс <code class="code">pfsync(4)</code> используется
            для наблюдения за таблицей состояний пакетного фильтра. При
            помощи утилиты <span><strong class="command">tcpdump(8)</strong></span> можно следить
            за таблицей состояний в режиме реального времени. Кроме
            того, <code class="code">pfsync(4)</code> позволяет
            посылать информацию об изменениях в таблице состояний по
            сети. Таким образом, другие пакетные фильтры на других
            машинах могут заносить эту информацию в свои таблицы. Таким
            образом, <code class="code">pfsync(4)</code> позволяет
            модифицировать таблицы состояния по сети.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pfsync-operation"></a>C.2.3.5.6. Использование с pfsync(4)</h5></div></div></div><p>
            По умолчанию <code class="code">pfsync(4)</code> не
            получает и не отсылает информации о состоянии соединений.
            Это не мешает следить за его деятельностью локально, при
            помощи <span><strong class="command">tcpdump(8)</strong></span>.
          </p><p>
            Когда <code class="code">pfsync(4)</code> конфигурируется
            для отправки или получения информации, он начинает рассылать
            её при помощи multicast пакетов в локальной сети. Все
            оповещения <code class="code">pfsync(4)</code> отсылает без
            аутентификации. Наилучшая практика состоит в том, чтобы:
          </p><div class="orderedlist"><ol type="1"><li>
              Соединить машины &#171;спина к спине&#187; при помощи
              отдельного пачкорда (кросс). и использовать опцию <code class="code">syncdev</code> (см. ниже).
            </li><li>
              Использовать опцию <span><strong class="command">ifconfig(8)</strong></span><code class="code">syncpeer</code> (см. ниже). Это приведёт к
              тому, что информация будет отсылаться по unicast адресу.
              Затем надо зашифровать трафик между партнёрами при помощи
              <code class="code">ipsec(4)</code>.
            </li></ol></div><p>
            При обмене сообщениями <code class="code">pfsync(4)</code>
            надо сконфигурировать пакетный фильтр так, чтобы он начал
            этот трафик пропускать (pfsync использует свой протокол
            сетевого уровня, номер 240, этот номер официально не
            утверждён IANA):
          </p><div class="informalexample"><pre class="programlisting">pass on $sync_if proto pfsync
            </pre></div><p>
            Здесь <code class="code">$sync_if</code>&nbsp;&#8212;
            интерфейс, через который идёт обмен информацией.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pfsync-config"></a>C.2.3.5.7. Конфигурирование pfsync</h5></div></div></div><p>
            Поскольку <code class="code">pfsync(4)</code>&nbsp;&#8212;
            виртуальный сетевой интерфейс, его можно конфигурировать
            используя <span><strong class="command">ifconfig(8)</strong></span>:
          </p><div class="informalexample"><pre class="programlisting">ifconfig &lt;pfsyncN&gt; syncdev &lt;syncdev&gt; [syncpeer &lt;syncpeer&gt;]
            </pre></div><div class="variablelist"><dl><dt><span class="term"><code class="code">pfsyncN</code></span></dt><dd>
                Имя интерфейса <code class="code">pfsync(4)</code>. При
                использовании ядра GENERIC интерфейс <code class="code">pfsync0</code> существует по умолчанию.
                Это относится и к <span class="acronym">OpenBSD</span> и к
                <span class="acronym">FreeBSD</span>.
              </dd><dt><span class="term"><code class="code">syncdev</code></span></dt><dd>
                Имя интерфейса, который используется <code class="code">pfsync(4)</code> для сетевых обновлений.
              </dd><dt><span class="term"><code class="code">syncpeer</code></span></dt><dd>
                Этот дополнительный параметр используется для указания
                хоста, с которым идёт обмен данными. По умолчанию <code class="code">pfsync(4)</code> использует адрес
                multicast, а с данной опцией использует unicast.
              </dd></dl></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-pfsync-example"></a>C.2.3.5.8. Пример использования pfsync</h5></div></div></div><p>
            Пример:
          </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> ifconfig pfsync0 syncdev em1
            </pre></div><p>
            Эта команда включает <code class="code">pfsync(4)</code> на
            интерфейсе <code class="code">em1</code>. Исходящие пакеты
            отправляются при помощи multicast и доступны всем хостам в
            сети, на которых запущен pfsync.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-carp+pfsync-combine"></a>C.2.3.5.9. Совместное использование <span class="acronym">CARP</span> и
            pfsync для отказоустойчивости</h5></div></div></div><p>
            Совместное использование <span class="acronym">CARP</span> и pfsync
            позволяет создать два и более брандмауэра и объединить их в
            устойчивый полнофункциональный кластер. При этом
            <span class="acronym">CARP</span> реализует отказоустойчивую систему,
            а pfsync позволяет синхронизировать данные таблиц состояния,
            так, что при отказе мастера, запасная машина берёт на себя
            его функции и при этом не обрывает имеющиеся соединения.
          </p><p>
            Например, пусть у нас имеется два брандмауэра&nbsp;&#8212;
            fw1 и fw2:
          </p><div class="informalexample"><pre class="programlisting">              +----| WAN/Internet |----+
              |                        |
              |      общий адрес       |
              | +----192.0.2.100-----+ |
              | |                    | |
 192.0.2.1:em2|/                      \|em2:192.0.2.2
           +-----+        10.10.10.2+-----+
           | fw1 |-em1----------em1-| fw2 |
           +-----+10.10.10.1        +-----+
172.16.0.1:em0|\                      /|em0:172.16.0.2
              | |                    | | 
              | +----172.16.0.100----+ |
              |      общий адрес       |
              |                        |
           ---+-------Shared LAN-------+---
            </pre></div><p>
            Брандмауэры соединены &#171;спина к спине&#187; через кросс
            через интерфейсы em1. Оба соединены с локальной сетью при
            помощи интерфейсов em0 и с внешней сетью через интерфейсы
            em2. Адреса показаны на схеме. Мастер&nbsp;&#8212; fw1.
          </p><p>
            Конфигурируем fw1:
          </p><div class="informalexample"><pre class="screen">Выполняем необходимые настройки в ядре:
<code class="prompt">#</code> sysctl -w net.inet.carp.preempt=1

Настраиваем pfsync
<code class="prompt">#</code> ifconfig em1 10.10.10.1 netmask 255.255.255.0
<code class="prompt">#</code> ifconfig pfsync0 syncdev em1
<code class="prompt">#</code> ifconfig pfsync0 up

Настраиваем CARP на внутреннем интерфейсе
<code class="prompt">#</code> ifconfig carp1 create
<code class="prompt">#</code> ifconfig carp1 vhid 1 carpdev em0 pass lanpasswd \
     172.16.0.100 netmask 255.255.255.0

Настраиваем CARP на внешнем интерфейсе
<code class="prompt">#</code> ifconfig carp2 create
<code class="prompt">#</code> ifconfig carp2 vhid 2 carpdev em2 pass netpasswd \
    192.0.2.100 netmask 255.255.255.0
            </pre></div><p>
            Конфигурируем fw2:
          </p><div class="informalexample"><pre class="screen">Выполняем необходимые настройки в ядре:
<code class="prompt">#</code> sysctl -w net.inet.carp.preempt=1

Настраиваем pfsync
<code class="prompt">#</code> ifconfig em1 10.10.10.2 netmask 255.255.255.0
<code class="prompt">#</code> ifconfig pfsync0 syncdev em1
<code class="prompt">#</code> ifconfig pfsync0 up

Настраиваем CARP на внутреннем интерфейсе
<code class="prompt">#</code> ifconfig carp1 create
<code class="prompt">#</code> ifconfig carp1 vhid 1 carpdev em0 pass lanpasswd \
     advskew 128 172.16.0.100 netmask 255.255.255.0

Настраиваем CARP на внешнем интерфейсе
<code class="prompt">#</code> ifconfig carp2 create
<code class="prompt">#</code> ifconfig carp2 vhid 2 carpdev em2 pass netpasswd \
    advskew 128 192.0.2.100 netmask 255.255.255.0
            </pre></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-carp+pfsync-issues"></a>C.2.3.5.10. Замечания по использованию <span class="acronym">CARP</span> и pfsync</h5></div></div></div><p>
            Некоторые распространённые проблемы при использовании
            <span class="acronym">CARP</span> и <code class="code">pfsync(4)</code>.
          </p><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-carp+pfsync-boot"></a>C.2.3.5.10.1. Конфигурирование <span class="acronym">CARP</span> и pfsync при
              загрузке</h6></div></div></div><p>
              И <code class="code">carpN</code> и <code class="code">pfsyncN</code> являются сетевыми
              интерфейсами и настраиваются так как дожны настраиваться
              обычные сетевые интерфейсы (см: <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/ch06s02.html#3.6.2-save" title="6.2.6. Как сохранить установленные сетевые параметры">Раздел&nbsp;6.2.6, &#171;Как сохранить установленные сетевые параметры&#187;</a>). В <span class="acronym">OpenBSD</span>
              создаётся файл hostname.if:
            </p><p>
              Файл <code class="filename">/etc/hostname.carp1</code>:
            </p><div class="informalexample"><pre class="programlisting">inet 172.16.0.100 255.255.255.0 172.16.0.255 vhid 1 carpdev em0 \
    pass lanpasswd
              </pre></div><p>
              Файл <code class="filename">/etc/hostname.pfsync0</code>:
            </p><div class="informalexample"><pre class="programlisting">up syncdev em1
              </pre></div><p>
              В <span class="acronym">FreeBSD</span> вам понадобятся следующие
              строки в <code class="filename">/etc/rc.conf</code>:
            </p><div class="informalexample"><pre class="programlisting">ifconfig_carp1="172.16.0.100/24 vhid 1 carpdev em0 pass lanpasswd"
ifconfig_pfsync0="up suncdev em1"
              </pre></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-carp+pfsync-failover"></a>C.2.3.5.10.2. Переназначение мастера</h6></div></div></div><p>
              Иногда бывает нужно перенести мастера с одного хоста на
              другой. Например, надо останивить мастера для
              профилактических работ или для отладки. Здесь
              обсуждается как это сделать не вредя имеющимся коннектам,
              чтобы пользователи ничего не заметили.
            </p><p>
              Для этих целей вы можете остановить интерфейс <code class="code">carp</code>. Мастер при этом выставит
              бесконечно большое значение <code class="code">advbase</code> и <code class="code">advskew</code> запасные машины немедленно
              это обнаружат и одна из них примет на себя обязанности
              мастера.
            </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> ifconfig carp1 down
              </pre></div><p>
              Другой вариант состоит в том, что вы увеличиваете значение
              <code class="code">advbase</code> и <code class="code">advskew</code> при этом обязанности
              мастера перейдут к запасной машине, но данная машина не
              будет удалена из группы <span class="acronym">CARP</span>.
            </p><p>
              Третий вариант состоит в том, чтобы управлять
              <span class="acronym">CARP</span>'ом при помощи переменной
              <code class="varname">demotion</code>. Эта возможность пока
              реализована только в <span class="acronym">OpenBSD</span>.
            </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Warning" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Внимание]" src="pf_02_files/warning.png"></td><th align="left">Внимание</th></tr><tr><td valign="top" align="left">
              Описанный механизм связанный с переменной
              <code class="varname">demotion</code> работает только в
              <span class="acronym">OpenBSD</span>.
            </td></tr></tbody></table></div><p>
              Переменная <code class="varname">demotion</code> присваивается
              группе интерфейсов. Повышая эту величину вы можете
              опустить <span class="acronym">CARP</span> на заданной группе
              интерфейсов. Текущее значение <code class="varname">demotion</code>
              можно увидеть при помощи команды
              <span><strong class="command">ifconfig(8)</strong></span>:
            </p><div class="informalexample"><pre class="screen"><code class="prompt">$</code> ifconfig -g carp
carp: carp demote count 0
              </pre></div><p>
              Здесь показано значение ассоциированное с группой <code class="code">carp</code>.
            </p><p>
              Рассмотрим такой пример: имеется два брандмауэра с
              запущенным <span class="acronym">CARP</span> со следующими
              <span class="acronym">CARP</span> интерфейсами:
            </p><div class="variablelist"><dl><dt><span class="term"><code class="code">carp1</code></span></dt><dd>
                  Первый отдел
                </dd><dt><span class="term"><code class="code">carp2</code></span></dt><dd>
                  Второй отдел
                </dd><dt><span class="term"><code class="code">carp3</code></span></dt><dd>
                  Интернет
                </dd><dt><span class="term"><code class="code">carp4</code></span></dt><dd>
                  ДМЗ
                </dd></dl></div><p>
              Задача состоит в том, чтобы перенести группы <code class="code">carp1</code> и <code class="code">carp2</code> на второй сервер.
            </p><p>
              Для начала присвоим эти интерфейсы группе
              &#171;internal&#187;:
            </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> ifconfig carp1 group internal
<code class="prompt">#</code> ifconfig carp2 group internal
<code class="prompt">$</code> ifconfig internal
carp1: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
     carp: MASTER carpdev em0 vhid 1 advbase 1 advskew 100
     groups: carp internal
     inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
carp2: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
     carp: MASTER carpdev em1 vhid 2 advbase 1 advskew 100
     groups: carp internal
     inet 10.0.1.1 netmask 0xffffff00 broadcast 10.0.1.255
              </pre></div><p>
              Теперь увеличим счётчик <code class="code">demotion</code> для группы internal при
              помощи <span><strong class="command">ifconfig(8)</strong></span>:
            </p><div class="informalexample"><pre class="screen"><code class="prompt">$</code> ifconfig -g internal
internal: carp demote count 0
<code class="prompt">#</code> ifconfig -g internal carpdemote 50
<code class="prompt">$</code> ifconfig -g internal
internal: carp demote count 50
              </pre></div><p>
              Теперь <span class="acronym">CARP</span> передаст полномочия по
              интерфейсам <code class="code">carp1</code> и <code class="code">carp2</code> на вторую машину, но
              останется мастером для <code class="code">carp3</code> и
              <code class="code">carp4</code>.
            </p><p>
              Чтобы вернуть полномчия обратно надо выполнить команду:
            </p><div class="informalexample"><pre class="screen"><code class="prompt">#</code> ifconfig -g internal -carpdemote 50
<code class="prompt">$</code> ifconfig -g internal
internal: carp demote count 0
              </pre></div><p>
              Некоторые сетевые демоны, такие как
              <span><strong class="command">OpenBGPD</strong></span> и
              <span><strong class="command">sasyncd(8)</strong></span> используют счётчик
              <code class="varname">demotion</code> для того, чтобы перед тем как
              установить BGP сессию или перед тем как синхронизировать
              IPSec SA, выяснить&nbsp;&#8212; является ли брандмауэр
              мастером.
            </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h6 class="title"><a name="pf-carp+pfsync-tips"></a>C.2.3.5.10.3. Советы по написанию правил фильтрации</h6></div></div></div><p>
              Фильтр должен работать на <span class="emphasis"><em>физическом</em></span>
              интерфейсе, не на виртуальном интерфейсе <code class="code">carp0</code>. Напрмер:
            </p><div class="informalexample"><pre class="programlisting">pass in on fxp0 inet proto tcp from any to carp0 port 22
              </pre></div><p>
              Если вы замените <code class="code">fxp0</code> на <code class="code">carp0</code> правило будет работать не
              так, как вы этого ожидаете.
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Замечание]" src="pf_02_files/note.png"></td><th align="left">Замечание</th></tr><tr><td valign="top" align="left">
              Не забывайте пропускать протокол <span class="acronym">CARP</span>
              при помощи правила <code class="code">proto carp</code> и
              трафик <code class="code">proto pfsync</code>.
            </td></tr></tbody></table></div></div></div></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h3 class="title"><a name="pf-ex1"></a>C.2.4. Пример: брандмауэр для дома или небольшого офиса</h3></div></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-ex1-scenario"></a>C.2.4.1. Сценарий</h4></div></div></div><p>
          В данном примере пакетный фильтр используется как брандмауэр и
          NAT в домашней сети или небольшом офисе. Задача состоит в
          том, чтобы обеспечить доступ из внутренней сети в Интернет,
          обеспечить ограниченный доступ к брандмауэру из Интернета и
          обеспечить доступ к внутреннему web-серверу из Интернет.
        </p><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-ex1-net"></a>C.2.4.1.1. Сеть</h5></div></div></div><p>
            Топология сети:
          </p><div class="informalexample"><pre class="programlisting">             WWW-server
[ COMP1 ]    [ COMP3 ]
   |            |                               
---+------+-----+------- xl0 [ BSD ] fxp0 -------- ( Internet )
          |
      [ COMP2 ]
            </pre></div><p>
            Во внутренней сети есть некоторое количество компьютеров.
            Сколько именно&nbsp;&#8212; неважно. У нас на диаграмме
            показано три. На компьютере COMP3 работает небольшой
            web-сервер. Внутренняя сеть 192.168.0.0/24
          </p><p>
            Брандмауэр работает на <span class="acronym">OpenBSD</span> (или любой
            другой <span class="acronym">BSD</span>) на процессоре
            Celeron&nbsp;300MHz с двумя сетевыми картами: 3com 3c905B
            (<code class="code">xl0</code>) и Intel EtherExpress
            Pro/100 (<code class="code">fxp0</code>). Брандмауэр
            соединён кабелем FastEthernet с провайдером. Для выхода
            внутренних машин в сеть используется NAT. Внешний адрес
            назначается провайдером динамически.
          </p></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-ex1-objective"></a>C.2.4.1.2. Задача</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li>
              Предоставить неограниченный доступ в Интернет каждой
              машине из внутренней сети.
            </li><li>
              Использовать политику &#171;default deny&#187;.
            </li><li><p>
                Разрешить следующий входящий трафик:
              </p><div class="itemizedlist"><ul type="circle"><li>
                  SSH (tcp порт 22): будет использоваться для
                  управления брандмауэром снаружи.
                </li><li>
                  Auth/Ident (tcp порт 113): используется некоторыми
                  сервисами, такими как SMTP и IRC.
                </li><li>
                  ICMP echo request: посылается командой
                  <span><strong class="command">ping(8)</strong></span>.
                </li></ul></div></li><li>
              Перенапрвить порт 80 (входящий трафик web-сервера) на
              машину COMP3. (И не забыть разрешить этот трафик в
              правилах фильтрации).
            </li><li>
              Собирать статистику фильтра на внешнем интерфейсе.
            </li><li>
              При блокировании пакетов отсылать пакеты TCP/RST и ICMP
              Unreachable.
            </li><li>
              Сделать правила простыми насколько это возможно, для
              удобства поддержки брандмауэра.
            </li></ul></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-ex1-prepare"></a>C.2.4.1.3. Подготовительные операции</h5></div></div></div><p>
            Мы считаем, что машина сконфигурирована как шлюз (т.е.
            включён проброс пакетов с интерфейса на интерфейс) и
            пакетный фильтр включён. О том как это делать написано в
            <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs01.html" title="C.1. Введение в работу с пакетным фильтром OpenBSD">Раздел&nbsp;C.1, &#171;Введение в работу с пакетным фильтром <span class="acronym">OpenBSD</span>&#187;</a>.
          </p></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-ex1-ruleset"></a>C.2.4.2. Поэтапное описание правил фильтрации</h4></div></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-ex1-ruleset-macro"></a>C.2.4.2.1. Макросы</h5></div></div></div><p>
            Определяем макросы для облегчения управления брандмауэром и
            упрощения набора правил:
          </p><div class="informalexample"><pre class="programlisting">ext_if="fxp0"
int_if="xl0"

tcp_services="{ 22, 113 }"
icmp_types="echoreq"

comp3="192.168.0.3"
            </pre></div><p>
            Первые две строки определяют сетевые интерфейсы брандмауэра.
            Если нам придётся перенести брандмауэр с машины на машину,
            нам надо будет изменить только эти две строчки, остальные
            правила будут по прежнему работоспособны. Третья и червёртая
            строки определяют номера открытых портов и типы ICMP
            сообщений принимаемых шлюзом. В последней строке задан адрес
            машины COMP3.
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Замечание]" src="pf_02_files/note.png"></td><th align="left">Замечание</th></tr><tr><td valign="top" align="left">
            Если соединение установлено через PPPoE, NAT трансляция
            должна осуществляться на интерфейсе <code class="code">tun0</code>, не на <code class="code">fxp0</code>.
          </td></tr></tbody></table></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-ex1-ruleset-options"></a>C.2.4.2.2. Опции</h5></div></div></div><p>
            Следующие две опции определяют поведение системы при
            блокировании пакетов и включают журналирование для внешнего
            интерфейса:
          </p><div class="informalexample"><pre class="programlisting">set block-policy return
set loginterface $ext_if
            </pre></div><p>
            Каждая <span class="acronym">UNIX</span>-система имеет кольцевой
            интерфейс, необходимый для того, чтобы программы могли
            общаться друг с другом при помощи сетевых протоколов внутри
            машины. Фильтрацию на кольцевом интерфейсе лучше
            отключить&nbsp;&#8212; чтобы не мешать работе программ.
          </p><div class="informalexample"><pre class="programlisting">set skip on lo
            </pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" valign="top" width="25" align="center"><img alt="[Замечание]" src="pf_02_files/note.png"></td><th align="left">Замечание</th></tr><tr><td valign="top" align="left">
            В <span class="acronym">OpenBSD</span><code class="code">lo</code>
            это группа кольцевых интерфейсов, поэтому при появлении
            нового сетевого интерфейса вам не придётся ни о чём
            специально заботиться. В остальных системах,
            <span class="acronym">FreeBSD</span>, <span class="acronym">NetBSD</span>,
            <span class="acronym">DragonFly&nbsp;BSD</span>, вам придётся
            определить эту опцию отдельно для каждого сетевого
            интерфейса <code class="code">lo0</code>, <code class="code">lo1</code> и т.д. (Случай когда их больше
            одного не част).
          </td></tr></tbody></table></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-ex1-ruleset-scrub"></a>C.2.4.2.3. Нормализация трафика</h5></div></div></div><p>
            Нет причин не использовать рекомендованные алгоритмы
            нормализации трафика. Поэтому нормализация, это всего одна
            строка:
          </p><div class="informalexample"><pre class="programlisting">scrub in
            </pre></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-ex1-ruleset-nat"></a>C.2.4.2.4. Трансляция NAT</h5></div></div></div><p>
            Следующее правило используется для трансляции NAT всей
            внутренней сети:
          </p><div class="informalexample"><pre class="programlisting">nat on $ext_if from !($ext_if) to any -&gt; ($ext_if)
            </pre></div><p>
            Мы можем заменить <code class="code">!($ext_if)</code> на
            <code class="code">$int_if</code>, но тогда нам придётся
            добавлять правила в брандмауэр, если мы добавим в шлюз ещё
            один интерфейс, который будет смотреть в другую внутреннюю
            сеть.
          </p><p>
            Круглые скобки вокруг интерфейса стоят потому, что адрес ему
            назначается динамически.
          </p><p>
            Для работы FTP-прокси, добавим якорь:
          </p><div class="informalexample"><pre class="programlisting">nat-anchor "ftp-proxy/*"
            </pre></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-ex1-ruleset-rdr"></a>C.2.4.2.5. Перенаправление</h5></div></div></div><p>
            Во-первых, нам понадобится правило перенаправления для работы
            <span><strong class="command">ftp-proxy(8)</strong></span>, чтобы клиенты из локальной
            сети могли пользоваться FTP:
          </p><div class="informalexample"><pre class="programlisting">rdr-anchor "ftp-proxy/*"
rdr on $int_if proto tcp from any to any port 21 -&gt; 127.0.0.1 port 8021
            </pre></div><p>
            Заметим, что здесь будет перенаправляться только FTP с
            управляющим каналом на порту 21. Если пользователи регулярно
            используют другие порты, следует использовать список: <code class="code">from any to any port {21, 221}</code>.
          </p><p>
            Во-вторых, нам надо перенаправить все входящие соединения на
            80-й порт машины COMP3.
          </p><div class="informalexample"><pre class="programlisting">rdr on $ext_if proto tcp from any to any port 80 -&gt; $comp3
            </pre></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h5 class="title"><a name="pf-ex1-ruleset-filter"></a>C.2.4.2.6. Фильтрация</h5></div></div></div><p>
            Для начала определяем политику default deny:
          </p><div class="informalexample"><pre class="programlisting">block in
            </pre></div><p>
            Здесь мы блокировали весь входящий трафик, даже из
            внутренней сети. Теперь мы будем по очереди описывать
            правила пропускающие нужный трафик.
          </p><p>
            Имейте ввиду, что пакетный фильтр может блокировать отдельно
            входящий трафик и отдельно исходящий. Мы с вами блокировали
            весь входящий трафик, но если пакет уже вошёл (т.е. он
            соответствовал разрешающему правилу, которое будет записано
            ниже), то мы можем его выпустить:
          </p><div class="informalexample"><pre class="programlisting">pass out keep state
            </pre></div><p>
            Нам понадобится якорь для <span><strong class="command">ftp-proxy(8)</strong></span>:
          </p><div class="informalexample"><pre class="programlisting">anchor "ftp-proxy/*"
            </pre></div><p>
            Неполохо так же защититься от спуфинга:
          </p><div class="informalexample"><pre class="programlisting">antispoof quick for { lo $int_if }
            </pre></div><p>
            Теперь откроем порты, используемые сервисами, котрые должны
            быть доступны из Интернет. Для начала, трафик предназначеный
            самому брандмауэру:
          </p><div class="informalexample"><pre class="programlisting">pass in on $ext_if inet proto tcp from any to ($ext_if) \
   port $tcp_services flags S/SA keep state
            </pre></div><p>
            Благодаря указанию портов в макросе <code class="code">$tcp_services</code> добавление нового
            сервиса предельно упрощается: достаточно просто
            отредактировать определение макроса и перегрузить набор
            правил. Чтобы добавить сервисы UDP можно просто добавить
            макрос <code class="code">$udp_services</code> аналогичным
            образом. При этом понадобится вставить такое же правило с
            указанием <code class="code">proto udp</code>.
          </p><p>
            Далее надо пропустить трафик идущий на машину COMP3, который
            прошёл трансляцию rdr:
          </p><div class="informalexample"><pre class="programlisting">pass in on $ext_if inet proto tcp from any to $comp3 port 80 \
    flags S/SA synproxy state
            </pre></div><p>
            Чтобы немного увеличить безопасность web-сервера мы
            используем <a href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs02.html#pf-pf.conf-rule-synproxy" title="C.2.1.4.9. TCP SYN proxy">TCP SYN
              Proxy</a>.
          </p><p>
            Пропускаем трафик ICMP:
          </p><div class="informalexample"><pre class="programlisting">pass in inet proto icmp all icmp-type $icmp_types keep state
            </pre></div><p>
            Аналогично макросу <code class="code">$tcp_services</code>,
            мы можем редактировать макрос <code class="code">$icmp_types</code>, чтобы варьировать типы
            пакетов принимаемых брандмауэром. Заметьте, это правило
            касается всех интерфейсов.
          </p><p>
            Теперь мы пропускаем весь трафик из внутренней сети. Мы
            предполагаем, что пользователи во внутренней сети знают что
            они делают и это не вызовет проблем. Однако во многих
            случаях это не так и понадобятся более жёсткие ограничения.
          </p><div class="informalexample"><pre class="programlisting">pass in quick on $int_if
            </pre></div><p>
            Трафик TCP, UDP и ICMP может покидать машину благодаря
            правилу &#171;<code class="code">pass out keep
              state</code>&#187;. Информация о состояниях сохраняется,
            таким образом, ответные пакеты тоже будут пропущены.
          </p></div></div><div class="section" lang="ru"><div class="titlepage"><div><div><h4 class="title"><a name="pf-ex1-complete-ruleset"></a>C.2.4.3. Полный листинг правил</h4></div></div></div><div class="informalexample"><pre class="programlisting"># макросы
ext_if="fxp0"
int_if="xl0"

tcp_services="{ 22, 113 }"
icmp_types="echoreq"

comp3="192.168.0.3"

# опции
set block-policy return
set loginterface $ext_if

set skip on lo

# нормализация трафика
scrub in

# nat/rdr
nat on $ext_if from !($ext_if) -&gt; ($ext_if:0)
nat-anchor "ftp-proxy/*"
rdr-anchor "ftp-proxy/*"

rdr pass on $int_if proto tcp to port ftp -&gt; 127.0.0.1 port 8021
rdr on $ext_if proto tcp from any to any port 80 -&gt; $comp3

# Фильтрация
block in

pass out keep state

anchor "ftp-proxy/*"
antispoof quick for { lo $int_if }

pass in on $ext_if inet proto tcp from any to ($ext_if) \
   port $tcp_services flags S/SA keep state

pass in on $ext_if inet proto tcp from any to $comp3 port 80 \
    flags S/SA synproxy state

pass in inet proto icmp all icmp-type $icmp_types keep state

pass quick on $int_if
          </pre></div></div></div></div><hr><div class="itemizedlist"><ul type="disc"><li><a href="http://house.hcn-strela.ru/BSDCert/">Легенда (условные обозначения)</a>.</li><li>Свежая версия данного <a href="http://house.hcn-strela.ru/BSDCert/">учебника по *BSD</a>.</li><li>Если вы нашли ошибку, выделите её в браузере и нажмите
                    клавиши &lt;Ctrl&gt;+&lt;Enter&gt; (пожалуйста,
                    &#171;зачёрпывайте&#187; окрестности ошибки, чтобы её было
                    легче найти в тексте)</li><li>Замечания и предложения можно высылать по адресу <img src="pf_02_files/email.png"></li><li>Автор, <a href="http://house.hcn-strela.ru/%7Eemin/cv.html">Евгений Миньковский</a>, ведёт
                    <a href="http://www.a-sys.ru/default.aspx?t13=7">курсы по администрированию
                        <acronym class="acronym">FreeBSD</acronym> и
                        <acronym class="acronym">Linux</acronym></a>.
                    в Академии Корпоративных Систем:
                    <a href="http://www.a-sys.ru/">http://www.a-sys.ru/</a></li></ul></div><div class="navfooter"><hr><table summary="Navigation footer" width="100%"><tbody><tr><td width="40%" align="left"><a accesskey="p" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs01.html"><img src="pf_02_files/prev.gif" alt="Пред."></a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apc.html"><img src="pf_02_files/up.gif" alt="Уровень выше"></a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/apcs03.html"><img src="pf_02_files/next.gif" alt="След."></a></td></tr><tr><td valign="top" width="40%" align="left">C.1. Введение в работу с пакетным фильтром <span class="acronym">OpenBSD</span>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="http://house.hcn-strela.ru/BSDCert/BSDA-course/index.html"><img src="pf_02_files/home.gif" alt="Начало"></a></td><td valign="top" width="40%" align="right">&nbsp;C.3. Управление пакетным фильтром <span class="acronym">OpenBSD</span>
      при помощи утилиты <span><strong class="command">pfctl(8)</strong></span></td></tr></tbody></table></div></body></html>